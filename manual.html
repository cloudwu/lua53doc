<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<head>
<title>Lua 5.3 参考手册</title>
<link rel="stylesheet" type="text/css" href="lua.css">
<link rel="stylesheet" type="text/css" href="manual.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=utf-8">
</head>

<body>

<hr>
<h1>
<a href="http://www.lua.org/"><img src="logo.gif" alt="" border="0"></a>
Lua 5.3 参考手册
</h1>

作者 Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes
<p>
译者 <a href="http://blog.codingnow.com">云风</a>
<p>
<small>
Lua.org, PUC-Rio 版权所有 &copy; 2015 ，
在遵循
<A HREF="http://www.lua.org/license.html">Lua license</A>
条款下，可自由使用。
</small>
<hr>
<p>

<a href="contents.html#contents">目录</A>
&middot;
<a href="contents.html#index">索引</A>
&middot;
<A HREF="term.html">中英术语对照表</A>

<!-- ====================================================================== -->
<p>

<!-- $Id: manual.of,v 1.146 2015/01/06 11:23:01 roberto Exp $ -->




<h1>1 &ndash; <a name="1">概要</a></h1>

<p>
Lua 是一门扩展式程序设计语言，它被设计成支持通用过程式编程，并有相关数据描述设施。
同时也很好的支持了面向对象编程、函数式编程、数据驱动式编程。
它作为一个强大、轻量的嵌入式脚本语言，可供任何需要的程序使用。
它以库形式实现，用 <em>clean C</em> 写成。
所谓 Clean C ，指的是标准 C 和 C++ 间共通的一个子集。


<p>
作为一个扩展式语言，Lua 没有 "main" 程序的概念：
它只能 <em>嵌入</em> 一个宿主程序中工作，
这个宿主程序被称作 <em>被嵌入的程序</em> 或简称为 <em>宿主</em> 。 
宿主程序可以调用函数执行一小段 Lua 代码，可以读写 Lua 变量，可以注入 C 函数让 Lua 代码调用。
依靠这些 C 函数，在各种不同的领域中，都可以将拥有相同句法结构的 Lua 定制为该领域下的编程语言。
Lua 的官方发布版包含了一个叫做 <code>lua</code> 的简单的宿主程序，
它用 Lua 库实现了一个完整的独立 Lua 解释器。
你可以把它作交互式应用或用于批处理。


<p>
Lua 是一个自由软件，它的使用许可证决定了它的使用过程没有任何担保。
这份手册中描述的实现，可以在 Lua 的官方网站 <code>www.lua.org</code> 找到。


<p>
跟其它的许多参考手册一样，这份文档有些地方比较枯燥。
Lua 设计决定方面的讨论，
可以看看 Lua 网站上提供的技术论文。
有关用 Lua 编程的细节介绍，
可以读一下 Roberto 的书，<em>Programming in Lua</em>。

<h1>2 &ndash; <a name="2">基本概念</a></h1>

<p>
这一章描述了语言的基本概念。



<h2>2.1 &ndash; <a name="2.1">值与类型</a></h2>

<p>
Lua 是一门<em>动态类型语言</em>。
这意味着变量没有类型；只有值才有类型。
语言中不设类型定义。
所有的值都带有自己的类型。


<p>
Lua 中所有的值都是 <em>一等公民</em>。
这意味着所有的值都可以保存在变量中、
当作参数传递给其它函数、以及作为返回值出现。


<p>
Lua 中有八种基本类型：
<em>nil</em>, <em>boolean</em>, <em>number</em>,
<em>string</em>, <em>function</em>, <em>userdata</em>,
<em>thread</em>, and <em>table</em>.
<em>Nil</em> 是值 <b>nil</b> 的类型，
它的主要特征就是和其它值区别开；
它通常用来表示一个有意义的值不存在时的状态。
<em>Boolean</em> 是 <b>false</b> 与 <b>true</b> 两个值的类型。
<b>nil</b> 和 <b>false</b> 都会导致条件判断为假；
所有其它的值都表现为真。
<em>Number</em> 代表了整数或实数（浮点数）。
<em>String</em> 表示一个不可变的字节序列。

Lua 是 8 位友好的：
字符串可以包含任意 8 位值，
其中包括零 ('<code>\0</code>') 。
Lua 的字符串编码无关；
它不理会字符串里的内容到底是什么。


<p>
<em>number</em> 类型有两种内部呈现方式，
一种称为 <em>整数</em> 另一种称为 <em>浮点数</em>。
对于使用哪种内部形式，Lua 有明确的规则，
但它也按需（参见 <a href="#3.4.3">&sect;3.4.3</a>）自动转换。
因此，程序员需要选择完全忽略其间的差异
还是对如何在内部呈现数字做完全的控制。
标准 Lua 使用 64 位整数以及双精度（64 位）浮点数，
但你可以把 Lua 编译成使用 32 位整数及单精度（32 位）浮点数。
以 32 位表示数字对小型机器以及嵌入式系统特别有意义。
（参见 <code>luaconf.h</code> 文件中的宏 <code>LUA_32BITS</code> 。）


<p>
Lua 可以调用（以及操作）用 Lua 或 C （参见 <a href="#3.4.10">&sect;3.4.10</a>）编写的函数。
这两种函数有统一的类型 <em>function</em>。


<p>
<em>userdata</em> 类型允许将 C 中的数据保存在 Lua 变量中。
用户数据类型的值是一个内存块。
有两种用户数据：
<em>完全用户数据</em> 指一块由 Lua 管理的内存对应的对象；
<em>轻量用户数据</em> 则指一个简单的 C 指针。
用户数据在 Lua 中没有预定义的操作，你只能对它进行赋值操作及判断两个用户数据是否相同。
使用 <em>元表</em> 的话，程序员可以给完全用户数据定义一系列的操作
（参见 <a href="#2.4">&sect;2.4</a>）。
在 Lua 代码中，你不能查和修改一个用户数据的值，这些工作只能通过 C API 完成。
这保证了数据仅被宿主程序所控制。


<p>
<em>thread</em> 类型表示了一个独立的执行序列，它被用于实现协程
（参见 <a href="#2.6">&sect;2.6</a>）。
Lua 线程并非操作系统线程。
Lua 为所有的系统，包括那些不提供原生线程支持的系统，提供了协程支持。


<p>
<em>table</em> 是一个关联数组，
也就是说，这个数组不仅仅以数做索引，除了 <b>nil</b> 和 NaN 之外的 Lua 值
都可以做索引。
（<em>Not a Number</em> 是一个特殊的数字，它用于表示未定义或表示不了的运算结果，比如 <code>0/0</code>。）
表可以是 <em>异构</em> 的；
也就是说，表内可以包含（除 <b>nil</b> 外的任何类型的值）。
任何键的值若为 <b>nil</b> 就不会被记入表结构内部。
换句话说，对于表内不存在的键，都对应着值 <b>nil</b> 。


<p>
表是 Lua 中唯一的数据结构；
它可被用于表示普通数组、序列、符号表、集合、记录、图、树、等等。
对于记录，Lua 使用域名作为索引。
语言提供了 <code>a.name</code> 这样的语法糖来替代
<code>a["name"]</code> 这种写法以方便记录这种结构的使用。
有多种方式在 Lua 中创建表结构（参见 <a href="#3.4.9">&sect;3.4.9</a>）。


<p>
我们使用 <em>序列</em> 这个术语来表示一个用 {1..<em>n</em>} 的正整数集
做索引的表。这里的非负整数 <em>n</em> 被称为这个序列的长度
（参见 <a href="#3.4.7">&sect;3.4.7</a>）。


<p>
和索引一样，表中每个域的值也可以是任何类型。
需要特别指出的是：既然函数是一等公民，那么表的域也可以是函数。
这样，表就可以携带 <em>方法</em> 了。
（参见 <a href="#3.4.11">&sect;3.4.11</a>）。


<p>
索引一张表的原则遵循语言中的直接比较规则。
当且仅当 <code>i</code> 与 <code>j</code>直接比较相等时
（即不通过元方法的比较），
表达式 <code>a[i]</code> 与 <code>a[j]</code>
表示了表中相同的元素。
特别指出：一个可以完全表达为整数的浮点数和对应的整数相等
（例如：<code>1.0 == 1</code>）。
为了消除歧义，当一个可以完全表达为整数的浮点数做为键值时，
都会被转换为对应的整数储存。
例如，当你写 <code>a[2.0] = true</code> 时，
实际被插入表中的键是整数 <code>2</code> 。
（另一方面，2 与 "<code>2</code>" 是两个不同的 Lua 值，
故而它们可以是同一张表中的不同项。）


<p>
表、函数、线程、以及完全用户数据在 Lua 中被称为 <em>对象</em>：
变量并不真的 <em>持有</em> 它们的值，而仅保存了对这些对象的 <em>引用</em>。
赋值、参数传递、函数返回，都是针对引用而不是针对值的操作；
这些操作均不会做任何形式的隐式拷贝。


<p>
库函数 <a href="#pdf-type"><code>type</code></a> 用于以字符串形式返回给定值的类型。
（参见 <a href="#6.1">&sect;6.1</a>）。




<h2>2.2 &ndash; <a name="2.2">环境与全局环境</a></h2>

<p>
后面在 <a href="#3.2">&sect;3.2</a> 以及 <a href="#3.3.3">&sect;3.3.3</a> 会讨论，
引用一个叫 <code>var</code> 的自由名字（指在任何层级都未被声明的名字）
在句法上都被翻译为 <code>_ENV.var</code> 。
此外，每个被编译的 Lua 代码块都会有一个额外的局部变量叫 <code>_ENV</code>
（参见 <a href="#3.3.2">&sect;3.3.2</a>），
因此，<code>_ENV</code> 这个名字永远都不会成为一个代码块中的自由名字。


<p>
在转译那些自由名字时，<code>_ENV</code> 是否是那个额外的局部变量无所谓。
<code>_ENV</code> 和其它你可以使用的变量名没有区别。
这里特别指出，你可以定义一个新变量或指定一个参数叫这个名字。
当编译器在转译自由名字时所用到的 <code>_ENV</code> ，
指的是你的程序在那个点上可见的那个名为 _ENV 的变量。
（Lua 的可见性规则参见 <a href="#3.5">&sect;3.5</a>）

<p>

被 <code>_ENV</code> 用于值的那张表被称为 <em>环境</em>。


<p>
Lua 保有一个被称为 <em>全局环境</em> 特别环境。它被保存在 C 注册表
（参见 <a href="#4.5">&sect;4.5</a>）的一个特别索引下。
在 Lua 中，全局变量 <a href="#pdf-_G"><code>_G</code></a> 被初始化为这个值。
（<a href="#pdf-_G"><code>_G</code></a> 不被内部任何地方使用。）


<p>
当 Lua 加载一个代码块，<code>_ENV</code> 这个上值的默认值就是这个全局环境
（参见 <a href="#pdf-load"><code>load</code></a>）。
因此，在默认情况下，Lua 代码中提及的自由名字都指的全局环境中的相关项
（因此，它们也被称为 <em>全局变量</em> ）。
此外，所有的标准库都被加载入全局环境，一些函数也针对这个环境做操作。
你可以用 <a href="#pdf-load"><code>load</code></a> （或 <a href="#pdf-loadfile"><code>loadfile</code></a>）加载代码块，并赋予它们不同的环境。
（在 C 里，当你加载一个代码块后，可以通过改变它的第一个上值来改变它的环境。）




<h2>2.3 &ndash; <a name="2.3">错误处理</a></h2>

<p>
Lua 作为一门嵌入式语言，
所有的 Lua 行为都始于宿主程序的 C 代码中对于 Lua 库里某函数的一次调用。
（当你使用 Lua 独立版本时，<code>lua</code> 程序就是那个宿主程序。）
在编译或运行一个 Lua 代码块时，无论发生任何错误，
控制权都返还给宿主。接下来可以针对情况来采取恰当的措施
（比如打印错误消息）。


<p>
Lua 代码中可以通过调用 <a href="#pdf-error"><code>error</code></a> 函数来显式的抛出一个错误。
如果你需要在 Lua 中捕获这些错误，
你可以使用 <a href="#pdf-pcall"><code>pcall</code></a> 或
<a href="#pdf-xpcall"><code>xpcall</code></a>
以 <em>保护模式</em> 来调用一个函数。


<p>
无论何时错误发生，都会产生一个携带有错误信息的 <em>错误对象</em> 
（也被称为 <em>错误消息</em>）。
Lua 本身只会产生字符串类型的错误对象，
但你的程序可以为一个错误抛出任何类型的错误对象。
这就看 Lua 程序或你的宿主如何处理这些错误对象了。

<p>
当你使用 <a href="#pdf-xpcall"><code>xpcall</code></a> 或
<a href="#lua_pcall"><code>lua_pcall</code></a> 时，
你应当给出一个 <em>消息处理器</em> 用于发生错误时的处理流程。
这个处理器函数会被传入原始的错误消息，并应返回一个新的错误消息。
它在错误发生后栈尚未展开时调用，
因此它可以通过栈来收集更多的信息。
例如它可以通过探知栈来创建一组栈回溯信息。
这个处理器函数也被保护模式调用以保护；
因此在处理器函数内发生的错误会再次调用它。
如果递归调用太深，Lua 会打破递归并返回一个恰当的消息。



<h2>2.4 &ndash; <a name="2.4">元表及元方法</a></h2>

<p>
Lua 中的每个值都可以用一个 <em>元表</em>。
这个 <em>元表</em> 就是一个普通的 Lua 表，
它用于定义原始值在特定操作下的行为。
如果你想改变一个值在特定操作下的行为，你可以在它的元表中设置对应域。
例如，当你对非数字值做加操作时，
Lua 会检查该值的元表中的 "<code>__add</code>" 域下的函数。
如果能找到，Lua 则调用这个函数来完成加这个操作。


<p>
元表中的键对应着不同的 <em>事件</em> 名；
键关联的那些值被称为 <em>元方法</em>。
在上面那个例子中引用的事件为 <code>"add"</code> ，
完成加操作的那个函数就是元方法。


<p>
你可以用 <a href="#pdf-getmetatable"><code>getmetatable</code></a> 函数
来获取任何值的元表。


<p>
使用 <a href="#pdf-setmetatable"><code>setmetatable</code></a> 
来替换一张表的元表。在 Lua 中，你不可以改变其它类型的值的元表
（除非你使用调试库（参见<a href="#6.10">&sect;6.10</a>））；
若想改变这些非表类型的值的元表，请使用 C API。


<p>
表和完全用户数据有独立的元表
（当然，多个表和用户数据可以共享同一个元表）。
其它类型的值按类型共享元表；
也就是说所有的数字都共享同一个元表，
所有的字符串共享另一个元表等等。
默认情况下，值是没有元表的，
但字符串库在初始化的时候为字符串类型设置了元表
（参见 <a href="#6.4">&sect;6.4</a>）。


<p>
元表决定了一个对象在数学运算、位运算、比较、连接、
取长度、调用、索引时的行为。
元表还可以定义一个函数，当表对象或用户数据对象在垃圾回收
（参见<a href="#2.5">&sect;2.5</a>）时调用它。


<p>
接下来会给出一张元表可以控制的事件的完整列表。
每个操作都用对应的事件名来区分。
每个事件的键名用加有 '<code>__</code>' 前缀的字符串来表示；
例如 "add" 操作的键名为字符串 "<code>__add</code>"。
注意、Lua 从元表中直接获取元方法；
访问元表中的元方法永远不会触发另一次元方法。
下面的代码模拟了 Lua 从一个对象 <code>obj</code> 中获取一个元方法的过程：

<pre>
     rawget(getmetatable(obj) or {}, "__" .. event_name)
</pre>

<p>
对于一元操作符（取负、求长度、位反），
元方法调用的时候，第二个参数是个哑元，其值等于第一个参数。
这样处理仅仅是为了简化 Lua 的内部实现
（这样处理可以让所有的操作都和二元操作一致），
这个行为有可能在将来的版本中移除。
（使用这个额外参数的行为都是不确定的。）


<ul>

<li><b>"add": </b>
<code>+</code> 操作。

如果任何不是数字的值（包括不能转换为数字的字符串）做加法，
Lua 就会尝试调用元方法。
首先、Lua 检查第一个操作数（即使它是合法的），
如果这个操作数没有为 "<code>__add</code>" 事件定义元方法，
Lua 就会接着检查第二个操作数。
一旦 Lua 找到了元方法，
它将把两个操作数作为参数传入元方法，
元方法的结果（调整为单个值）作为这个操作的结果。
如果找不到元方法，将抛出一个操作。
</li>

<li><b>"sub": </b>
<code>-</code> 操作。

行为和 "add" 操作类似。
</li>

<li><b>"mul": </b>
<code>*</code> 操作。

行为和 "add" 操作类似。
</li>

<li><b>"div": </b>
<code>/</code> 操作。

行为和 "add" 操作类似。
</li>

<li><b>"mod": </b>
<code>%</code> 操作。

行为和 "add" 操作类似。
</li>

<li><b>"pow": </b>
<code>^</code> （次方）操作。

行为和 "add" 操作类似。
</li>

<li><b>"unm": </b>
<code>-</code> （取负）操作。

行为和 "add" 操作类似。
</li>

<li><b>"idiv": </b>
<code>//</code> （向下取整除法）操作。

行为和 "add" 操作类似。
</li>

<li><b>"band": </b>
<code>&amp;</code> （按位与）操作。

行为和 "add" 操作类似，
不同的是 Lua 会在任何一个操作数无法转换为整数时
（参见 <a href="#3.4.3">&sect;3.4.3</a>）尝试取元方法。
</li>

<li><b>"bor": </b>
<code>|</code> （按位或）操作。

行为和 "band" 操作类似。
</li>

<li><b>"bxor": </b>
<code>~</code> （按位异或）操作。

行为和 "band" 操作类似。
</li>

<li><b>"bnot": </b>
<code>~</code> （按位非）操作。

行为和 "band" 操作类似。
</li>

<li><b>"shl": </b>
<code>&lt;&lt;</code> （左移）操作。

行为和 "band" 操作类似。
</li>

<li><b>"shr": </b>
<code>&gt;&gt;</code> （右移）操作。

行为和 "band" 操作类似。
</li>

<li><b>"concat": </b>
<code>..</code> （连接）操作。

行为和 "add" 操作类似，
不同的是 Lua 在任何操作数即不是一个字符串
也不是数字（数字总能转换为对应的字符串）的情况下尝试元方法。
</li>

<li><b>"len": </b>
<code>#</code> （取长度）操作。

如果对象不是字符串，Lua 会尝试它的元方法。
如果有元方法，则调用它并将对象以参数形式传入，
而返回值（被调整为单个）则作为结果。
如果对象是一张表且没有元方法，
Lua 使用表的取长度操作（参见 <a href="#3.4.7">&sect;3.4.7</a>）。
其它情况，均抛出错误。
</li>

<li><b>"eq": </b>
<code>==</code> （等于）操作。

和 "add" 操作行为类似，
不同的是 Lua 仅在两个值都是表或都是完全用户数据
且它们不是同一个对象时才尝试元方法。
调用的结果总会被转换为布尔量。
</li>

<li><b>"lt": </b>
<code>&lt;</code> （小于）操作。

和 "add" 操作行为类似，
不同的是 Lua 仅在两个值不全为整数也不全为字符串时才尝试元方法。
调用的结果总会被转换为布尔量。
</li>

<li><b>"le": </b>
<code>&lt;=</code> （小于等于）操作。

和其它操作不同，
小于等于操作可能用到两个不同的事件。
首先，像 "lt" 操作的行为那样，Lua 在两个操作数中查找 "<code>__le</code>" 元方法。
如果一个元方法都找不到，就会再次查找 "<code>__lt</code>" 事件，
它会假设 <code>a &lt;= b</code> 等价于 <code>not (b &lt; a)</code>。
而其它比较操作符类似，其结果会被转换为布尔量。
</li>

<li><b>"index": </b>
索引 <code>table[key]</code>。

当 <code>table</code> 不是表或是表 <code>table</code> 中不存在
<code>key</code> 这个键时，这个事件被触发。
此时，会读出 <code>table</code> 相应的元方法。

<p>
尽管名字取成这样，
这个事件的元方法其实可以是一个函数也可以是一张表。
如果它是一个函数，则以 <code>table</code> 和 <code>key</code> 作为参数调用它。
如果它是一张表，最终的结果就是以 <code>key</code> 取索引这张表的结果。
（这个索引过程是走常规的流程，而不是直接索引，
所以这次索引有可能引发另一次元方法。）
</li>

<li><b>"newindex": </b>
索引赋值 <code>table[key] = value</code> 。

和索引事件类似，它发生在
<code>table</code> 不是表或是表 <code>table</code> 中不存在
<code>key</code> 这个键的时候。
此时，会读出 <code>table</code> 相应的元方法。

<p>
同索引过程那样，
这个事件的元方法即可以是函数，也可以是一张表。
如果是一个函数，
则以 <code>table</code>、 <code>key</code>、以及 <code>value</code> 为参数传入。
如果是一张表，
Lua 对这张表做索引赋值操作。
（这个索引过程是走常规的流程，而不是直接索引赋值，
所以这次索引赋值有可能引发另一次元方法。）


<p>
一旦有了 "newindex" 元方法，
Lua 就不再做最初的赋值操作。
（如果有必要，在元方法内部可以调用 <a href="#pdf-rawset"><code>rawset</code></a>
来做赋值。）
</li>

<li><b>"call": </b>
函数调用操作 <code>func(args)</code>。

当 Lua 尝试调用一个非函数的值的时候会触发这个事件
（即 <code>func</code> 不是一个函数）。
查找 <code>func</code> 的元方法，
如果找得到，就调用这个元方法，
<code>func</code> 作为第一个参数传入，原来调用的参数（<code>args</code>）后依次排在后面。
</li>

</ul>




<h2>2.5 &ndash; <a name="2.5">垃圾收集</a></h2>

<p>
Lua 采用了自动内存管理。
这意味着你不用操心新创建的对象需要的内存如何分配出来，
也不用考虑在对象不再被使用后怎样释放它们所占用的内存。
Lua 运行了一个 <em>垃圾收集器</em> 来收集所有 <em>死对象</em>
（即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。
Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、
内部结构等，都服从自动管理。


<p>
Lua 实现了一个增量标记-扫描收集器。
它使用这两个数字来控制垃圾收集循环：
<em>垃圾收集器间歇率</em> 和 <em>垃圾收集器步进倍率</em>。
这两个数字都使用百分数为单位
（例如：值 100 在内部表示 1 ）。


<p>
垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。
增大这个值会减少收集器的积极性。
当这个值比 100 小的时候，收集器在开启新的循环前不会有等待。
设置这个值为 200 就会让收集器等到总内存使用量达到
之前的两倍时才开始新的循环。


<p>
垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。
增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。
不要把这个值设得小于 100 ，
那样的话收集器就工作的太慢了以至于永远都不干不完一个循环。
默认值是 200 ，这表示收集器以内存分配的“两倍”速工作。


<p>
如果你把步进倍率设为一个非常大的数字
（比你的程序可能用到的字节数还大 10% ），
收集器的行为就像一个 stop-the-world 收集器。
接着你若把间歇率设为 200 ，
收集器的行为就和过去的 Lua 版本一样了：
每次 Lua 使用的内存翻倍时，就做一次完整的收集。



<p>
你可以通过在 C 中调用 <a href="#lua_gc"><code>lua_gc</code></a>
或在 Lua 中调用 <a href="#pdf-collectgarbage"><code>collectgarbage</code></a>
来改变这俩数字。
这两个函数也可以用来直接控制收集器（例如停止它或重启它）。


<h3>2.5.1 &ndash; <a name="2.5.1">垃圾收集元方法</a></h3>

<p>
你可以为表设定垃圾收集的元方法，
对于完全用户数据（参见 <a href="#2.4">&sect;2.4</a>），
则需要使用 C API 。
该元方法被称为 <em>终结器</em>。
终结器允许你配合 Lua 的垃圾收集器做一些额外的资源管理工作
（例如关闭文件、网络或数据库连接，或是释放一些你自己的内存）。


<p>
如果要让一个对象（表或用户数据）在收集过程中进入终结流程，
你必须 <em>标记</em> 它需要触发终结器。

当你为一个对象设置元表时，若此刻这张元表中用一个以字符串
"<code>__gc</code>" 为索引的域，那么就标记了这个对象需要触发终结器。
注意：如果你给对象设置了一个没有 <code>__gc</code>
域的元表，之后才给元表加上这个域，
那么这个对象是没有被标记成需要触发终结器的。
然而，一旦对象被标记，
你还是可以自由的改变其元表中的 <code>__gc</code> 域的。


<p>
当一个被标记的对象成为了垃圾后，
垃圾收集器并不会立刻回收它。
取而代之的是，Lua 会将其置入一个链表。
在收集完成后，Lua 将遍历这个链表。
Lua 会检查每个链表中的对象的 <code>__gc</code>
元方法：如果是一个函数，那么就以对象为唯一参数调用它；
否则直接忽略它。


<p>
在每次垃圾收集循环的最后阶段，
本次循环中检测到的需要被回收之对象，
其终结器的触发次序按当初给对象作需要触发终结器的标记之次序的逆序进行；
这就是说，第一个被调用的终结器是程序中最后一个被标记的对象所携的那个。
每个终结器的运行可能发生在执行常规代码过程中的任意一刻。


<p>
由于被回收的对象还需要被终结器使用，
该对象（以及仅能通过它访问到的其它对象）一定会被 Lua <em>复活</em>。
通常，复活是短暂的，对象所属内存会在下一个垃圾收集循环释放。
然后，若终结器又将对象保存去一些全局的地方
（例如：放在一个全局变量里），这次复活就持续生效了。
此外，如果在终结器中对一个正进入终结流程的对象再次做一次标记让它触发终结器，
只要这个对象在下个循环中依旧不可达，它的终结函数还会再调用一次。
无论是哪种情况，
对象所属内存仅在垃圾收集循环中该对象不可达且
没有被标记成需要触发终结器才会被释放。


<p>
当你关闭一个状态机（参见 <a href="#lua_close"><code>lua_close</code></a>），
Lua 将调用所有被标记了需要触发终结器对象的终结过程，
其次序为标记次序的逆序。
在这个过程中，任何终结器再次标记对象的行为都会不会生效。





<h3>2.5.2 &ndash; <a name="2.5.2">弱表</a></h3>

<p>
<em>弱表</em> 指内部元素为 <em>弱引用</em> 的表。
垃圾收集器会忽略掉弱引用。
换句话说，如果一个对象只被弱引用引用到，
垃圾收集器就会回收这个对象。


<p>
一张弱表可以有弱键或是弱值，也可以键值都是弱引用。
仅含有弱键的表允许收集器回收它的键，但会阻止对值所指的对象被回收。
若一张表的键值均为弱引用，
那么收集器可以回收其中的任意键和值。
任何情况下，只要键或值的任意一项被回收，
相关联的键值对都会从表中移除。
一张表的元表中的 <code>__mode</code> 域控制着这张表的弱属性。
当 <code>__mode</code> 域是一个包含字符 '<code>k</code>'
的字符串时，这张表的所有键皆为弱引用。
当 <code>__mode</code> 域是一个包含字符 '<code>v</code>'
的字符串时，这张表的所有值皆为弱引用。


<p>
属性为弱键强值的表也被称为 <em>暂时表</em>。
对于一张暂时表，
它的值是否可达仅取决于其对应键是否可达。
特别注意，如果表内的一个键仅仅被其值所关联引用，
这个键值对将被表内移除。


<p>
对一张表的弱属性的修改仅在下次收集循环才生效。
尤其是当你把表由弱改强，Lua 还是有可能在修改生效前回收表内一些项目。


<p>
只有那些有显式构造过程的对象才会被弱表中移除。
值，例如数字和轻量 C 函数，不受垃圾收集器管辖，
因此不会从弱表中移除
（除非它们的关联项被回收）。
虽然字符串受垃圾回收器管辖，
但它们没有显式的构造过程，所以也不会从弱表中移除。


<p>
弱表针对复活的对象
（指那些正在走终结流程，仅能被终结器访问的对象）
有着特殊的行为。
弱值引用的对象，在运行它们的终结器前就被移除了，
而弱键引用的对象则要等到终结器运行完毕后，到下次收集当对象真的被释放时才被移除。
这个行为使得终结器运行时得以访问到由该对象在弱表中所关联的属性。


<p>
如果一张弱表在当次收集循环内的复活对象中，
那么在下个循环前这张表有可能未被正确地清理。






<h2>2.6 &ndash; <a name="2.6">协程</a></h2>

<p>
Lua 支持协程，同时它也被称为 <em>协同式多线程</em>。
Lua 为每个协程提供一个独立的运行序。
然而和多线程系统中的线程不同，
协程仅在显式地调用一个让出函数时才挂起当前的执行状态。


<p>
通过调用
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>
可创建一个协程。
它唯一的参数是一个函数，这个函数将作为这个协程的主函数。
<code>create</code> 函数仅仅创建出这个协程然后返回它的句柄
（一个类型为 <em>thread</em> 的对象）；
它并不运行该协程。


<p>
通过调用
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
可执行一个协程。
第一次调用
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
时，第一个参数应传入
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>
返回的线程对象，这样协程就会从其主函数的第一行开始执行。
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
后面的参数将作为主函数的参数传入。
协程将一直运行到它结束或 <em>让出</em>。


<p>
协程的运行可能被两种方式终止：
正常途径是主函数返回
（显式返回或运行完最后一条指令）；
非正常途径是发生了一个未被捕获的错误。
对于正常结束，
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 将返回 <b>true</b>，
并接上协程主函数的返回值。
当错误发生时，
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 将返回 <b>false</b>
与错误消息。


<p>
让出协程的执行通过调用
<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> 完成。
当协程让出，
即使让出发生在内嵌函数调用中
（即不在主函数，但在主函数直接或间接调用的函数内部），
之前对该协程调用的 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 会立刻返回。
在让出的情况下，
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 依旧返回 <b>true</b>，
接下来的返回值是传给
<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> 的那些参数。
当下一次你延续同一个协程时，
协程会接在让出点继续运行。
调用 <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>
的让出点会返回传给
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
的额外参数。


<p>
就像
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a> 那样，
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> 函数也会创建一个协程。
不同的是，它不返回协程本身，而是返回一个函数。
调用这个函数将延续这个协程。
为这个函数提供的参数相当于
传给 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 的额外参数。
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>
的返回值是
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
的返回值中除去第一个返回值（布尔型的错误码）剩余的部分。
和 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 不同，
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>
不会捕获错误；
错误会传播给调用者。


<p>
下面的代码展示了一个协程工作的范例：

<pre>
     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
     
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</pre><p>
当你运行它，将产生下列输出：

<pre>
     co-body 1       10
     foo     2
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</pre>

<p>
你也可以通过 C API 来创建及操作协程：
参见函数
<a href="#lua_newthread"><code>lua_newthread</code></a>，
<a href="#lua_resume"><code>lua_resume</code></a>，
以及 <a href="#lua_yield"><code>lua_yield</code></a>。





<h1>3 &ndash; <a name="3">语言定义</a></h1>

<p>
这一章描述了 Lua 的词法、语法和句法。
换句话说，本章描述哪些符记是有效的，
它们如何被组合起来，这些组合方式有什么含义。


<p>
关于语言的构成概念将用常见的扩展 BNF 表达式写出。
也就是这个样子：
{<em>a</em>} 表示 0 或多个 <em>a</em>，
[<em>a</em>] 表示一个可选的 <em>a</em>。

可以被分解的非最终符号会这样写 non-terminal ，
关键字会写成这样 <b>kword</b>，
而其它不能被分解的最终符号则写成这样 &lsquo;<b>=</b>&rsquo; 。
完整的 Lua 语法可以在本手册最后一章 <a href="#9">&sect;9</a> 找到。



<h2>3.1 &ndash; <a name="3.1">词法约定</a></h2>

<p>
Lua 语言的格式自由。
它会忽略语法元素（符记）间的空格（包括换行）和注释，
仅把它们看作为名字和关键字间的分割符。


<p>
Lua 中的 <em>名字</em>
（也被称为 <em>标识符</em>）
可以是由非数字打头的任意字母下划线和数字构成的字符串。
标识符可用于对变量、表的域、以及标签命名。


<p>
下列 <em>关键字</em> 是保留的，不可用于名字：


<pre>
     and       break     do        else      elseif    end
     false     for       function  goto      if        in
     local     nil       not       or        repeat    return
     then      true      until     while
</pre>

<p>
Lua 语言对大小写敏感：
<code>and</code> 是一个保留字，但 <code>And</code> 与 <code>AND</code>
则是两个不同的有效名字。
作为一个约定，程序应避免创建以下划线加一个或多个大写字母构成的名字
（例如 <a href="#pdf-_VERSION"><code>_VERSION</code></a>）。


<p>
下列字符串是另外一些符记：

<pre>
     +     -     *     /     %     ^     #
     &amp;     ~     |     &lt;&lt;    &gt;&gt;    //
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]     ::
     ;     :     ,     .     ..    ...
</pre>

<p>
<em>字面串</em> 可以用单引号或双引号括起。
字面串内部可以包含下列 C 风格的转义串： 
'<code>\a</code>' （响铃），
'<code>\b</code>' （退格），
'<code>\f</code>' （换页），
'<code>\n</code>' （换行），
'<code>\r</code>' （回车），
'<code>\t</code>' （横项制表），
'<code>\v</code>' （纵向制表），
'<code>\\</code>' （反斜杠），
'<code>\"</code>' （双引号），
以及 '<code>\'</code>' (单引号)。
在反斜杠后跟一个真正的换行等价于在字符串中写一个换行符。
转义串 '<code>\z</code>' 会忽略其后的一系列空白符，包括换行；
它在你需要对一个很长的字符串常量断行为多行并希望在每个新行保持缩进时非常有用。



<p>
Lua 中的字符串可以保存任意 8 位值，其中包括用 '<code>\0</code>' 表示的 0 。
一般而言，你可以用字符的数字值来表示这个字符。
方式是用转义串 <code>\x<em>XX</em></code>，
此处的 <em>XX</em> 必须是恰好两个字符的 16 进制数。
或者你也可以使用转义串 <code>\<em>ddd</em></code> ，
这里的 <em>ddd</em> 是一到三个十进制数字。
（注意，如果在转义符后接着恰巧是一个数字符号的话，
你就必须在这个转义形式中写满三个数字。）


<p>
对于用 UTF-8 编码的 Unicode 字符，你可以用
转义符 <code>\u{<em>XXX</em>}</code> 来表示
（这里必须有一对花括号），
此处的 <em>XXX</em> 是用 16 进制表示的字符编号。


<p>
字面串还可以用一种 <em>长括号</em> 括起来的方式定义。
我们把两个正的方括号间插入 <em>n</em> 个等号定义为 <em>第 <em>n</em> 级开长括号</em>。
就是说，0 级开的长括号写作 <code>[[</code> ， 一级开长括号写作 <code>[=[</code> ，
如此等等。
<em>闭长括号</em>也作类似定义； 
举个例子，4 级反的长括号写作 <code>]====]</code> 。
一个 <em>长字面串</em> 可以由任何一级的开长括号开始，而由第一个碰到的同级的闭长括号结束。
这种方式描述的字符串可以包含任何东西，当然特定级别的反长括号除外。
整个词法分析过程将不受分行限制，不处理任何转义符，并且忽略掉任何不同级别的长括号。 
其中碰到的任何形式的换行串（回车、换行、回车加换行、换行加回车），都会被转换为单个换行符。


<p>
字面串中的每个不被上述规则影响的字节都呈现为本身。
然而，Lua 是用文本模式打开源文件解析的，
一些系统的文件操作函数对某些控制字符的处理可能有问题。
因此，对于非文本数据，用引号括起来并显式按转义符规则来表述更安全。


<p>
为了方便起见，
当一个开长括号后紧接一个换行符时，
这个换行符不会放在字符串内。
举个例子，假设一个系统使用 ASCII 码
（此时 '<code>a</code>' 编码为 97 ，
换行编码为 10 ，'<code>1</code>' 编码为 49 ），
下面五种方式描述了完全相同的字符串：

<pre>
     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</pre>

<p>
<em>数字常量</em> （或称为 <em>数字量</em>）
可以由可选的小数部分和可选的十为底的指数部分构成，
指数部分用字符 '<code>e</code>' 或 '<code>E</code>' 来标记。
Lua 也接受以 <code>0x</code> 或 <code>0X</code> 开头的 16 进制常量。
16 进制常量也接受小数加指数部分的形式，指数部分是以二为底，
用字符 '<code>p</code>' 或 '<code>P</code>' 来标记。
数字常量中包含小数点或指数部分时，被认为是一个浮点数；
否则被认为是一个整数。
下面有一些合法的整数常量的例子：
<pre>
     3   345   0xff   0xBEBADA
</pre><p>
以下为合法的浮点常量：
<pre>
     3.0     3.1416     314.16e-2     0.31416E1     34e1
     0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
</pre>

<p>
在字符串外的任何地方出现以双横线 (<code>--</code>) 开头的部分是 <em>注释</em> 。
如果 <code>--</code> 后没有紧跟着一个开大括号，
该注释为 <em>短注释</em>，
注释到当前行末截至。
否则，这是一段 <em>长注释</em> ，
注释区一直维持到对应的闭长括号。
长注释通常用于临时屏蔽掉一大段代码。



<h2>3.2 &ndash; <a name="3.2">变量</a></h2>

<p>
变量是储存值的地方。
Lua 中有三种变量：
全局变量、局部变量和表的域。


<p>
单个名字可以指代一个全局变量也可以指代一个局部变量
（或者是一个函数的形参，这是一种特殊形式的局部变量）。

<pre>
	var ::= Name
</pre><p>
名字指 <a href="#3.1">&sect;3.1</a> 中定义的标识符。


<p>
所有没有显式声明为局部变量（参见 <a href="#3.3.7">&sect;3.3.7</a>）
的变量名都被当做全局变量。
局部变量有其 <em>作用范围</em> ：
局部变量可以被定义在它作用范围中的函数自由使用（参见
<a href="#3.5">&sect;3.5</a>）。


<p>
在变量的首次赋值之前，变量的值均为 <b>nil</b>。


<p>
方括号被用来对表作索引：

<pre>
	var ::= prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo;
</pre><p>
对全局变量以及表的域之访问的含义可以通过元表来改变。 
以索引方式访问一个变量 <code>t[i]</code> 等价于
调用 <code>gettable_event(t,i)</code>。
（参见 <a href="#2.4">&sect;2.4</a> ，有一份完整的关于
<code>gettable_event</code> 函数的说明。
这个函数并没有在 lua 中定义出来，也不能在 lua 中调用。这里我们把提到它只是方便说明问题。）


<p>
<code>var.Name</code> 这种语法只是一个语法糖，用来表示
<code>var["Name"]</code>：

<pre>
	var ::= prefixexp &lsquo;<b>.</b>&rsquo; Name
</pre>

<p>
对全局变量 <code>x</code> 的操作等价于操作
<code>_ENV.x</code>。
由于代码块编译的方式，
<code>_ENV</code> 永远也不可能是一个全局名字 （参见 <a href="#2.2">&sect;2.2</a>）。





<h2>3.3 &ndash; <a name="3.3">语句</a></h2>

<p>
Lua 支持所有与 Pascal 或是 C 类似的常见形式的语句，
这个集合包括赋值，控制结构，函数调用，还有变量声明。



<h3>3.3.1 &ndash; <a name="3.3.1">语句块</a></h3>

<p>
语句块是一个语句序列，它们会按次序执行：

<pre>
	block ::= {stat}
</pre><p>
Lua 支持 <em>空语句</em>，
你可以用分号分割语句，也可以以分号开始一个语句块，
或是连着写两个分号：

<pre>
	stat ::= &lsquo;<b>;</b>&rsquo;
</pre>

<p>
函数调用和赋值语句都可能以一个小括号打头，
这可能让 Lua 的语法产生歧义。
我们来看看下面的代码片断：

<pre>
     a = b + c
     (print or io.write)('done')
</pre><p>
从语法上说，可能有两种解释方式：

<pre>
     a = b + c(print or io.write)('done')
     
     a = b + c; (print or io.write)('done')
</pre><p>
当前的解析器总是有第一种结构来解析，
它会将开括号看成函数调用的参数传递开始处。
为了避免这种二义性，
在一条语句以小括号开头时，前面放一个分号是个好习惯：

<pre>
     ;(print or io.write)('done')
</pre>

<p>

一个语句块可以被显式的定界为单条语句：

<pre>
	stat ::= <b>do</b> block <b>end</b>
</pre><p>
显式的对一个块定界通常用来控制内部变量声明的作用域。
有时，显式定界也用于在一个语句块中间插入
<b>return</b> （参见 <a href="#3.3.4">&sect;3.3.4</a>）。





<h3>3.3.2 &ndash; <a name="3.3.2">代码块</a></h3>

<p>
Lua 的一个编译单元被称为一个 <em>代码块</em>。
从句法构成上讲，一个代码块就是一个语句块。

<pre>
	chunk ::= block
</pre>

<p>
Lua 把一个代码块当作一个拥有不定参数的匿名函数
（参见<a href="#3.4.11">&sect;3.4.11</a>）来处理。
正是这样，代码块内可以定义局部变量，它可以接收参数，返回若干值。
此外，这个匿名函数在编译时还为它的作用域绑定了一个外部局部变量
<code>_ENV</code> （参见 <a href="#2.2">&sect;2.2</a>）。
该函数总是把 <code>_ENV</code> 作为它唯一的一个上值，
即使这个函数不使用这个变量，它也存在。


<p>
代码块可以被保存在文件中，也可以作为宿主程序内部的一个字符串。
要执行一个代码块，
首先要让 Lua <em>加载</em> 它，
将代码块中的代码预编译成虚拟机中的指令，
而后，Lua 用虚拟机解释器来运行编译后的代码。


<p>
代码块可以被预编译为二进制形式；
参见程序  <code>luac</code> 以及函数 <a href="#pdf-string.dump"><code>string.dump</code></a> 可获得更多细节。
用源码表示的程序和编译后的形式可自由替换；
Lua 会自动检测文件格式做相应的处理
（参见 <a href="#pdf-load"><code>load</code></a>）。





<h3>3.3.3 &ndash; <a name="3.3.3">赋值</a></h3>

<p>
Lua 允许多重赋值。
因此，赋值的语法定义是等号左边放一个变量列表， 而等号右边放一个表达式列表。
两边的列表中的元素都用逗号间开：

<pre>
	stat ::= varlist &lsquo;<b>=</b>&rsquo; explist
	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}
	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}
</pre><p>
表达式放在 <a href="#3.4">&sect;3.4</a> 中讨论。


<p>
在作赋值操作之前，
那值列表会被 <em>调整</em> 为左边变量列表的个数。
如果值比需要的更多的话，多余的值就被扔掉。 
如果值的数量不够需求，
将会按所需扩展若干个 <b>nil</b>。
如果表达式列表以一个函数调用结束，
这个函数所返回的所有值都会在调整操作之前被置入值列表中
（除非这个函数调用被用括号括了起来；参见 <a href="#3.4">&sect;3.4</a>）。



<p>
赋值语句首先让所有的表达式完成运算，
之后再做赋值操作。
因此，下面这段代码

<pre>
     i = 3
     i, a[i] = i+1, 20
</pre><p>
会把 <code>a[3]</code> 设置为 20，而不会影响到 <code>a[4]</code> 。
这是因为 <code>a[i]</code> 中的 <code>i</code> 在被赋值为 4 之前就被计算出来了（当时是 3 ）。 
简单说 ，这样一行

<pre>
     x, y = y, x
</pre><p>
会交换 <code>x</code> 和 <code>y</code> 的值，
及

<pre>
     x, y, z = y, z, x
</pre><p>
会轮换 <code>x</code>，<code>y</code>，<code>z</code> 的值。


<p>
对全局变量以及表的域的赋值操作的含义可以通过元表来改变。
对 <code>t[i] = val</code> 这样的变量索引赋值，
等价于 <code>settable_event(t,i,val)</code>。
（关于函数 <code>settable_event</code> 的详细说明，参见
<a href="#2.4">&sect;2.4</a>。
这个函数并没有在 Lua 中定义出来，也不可以被调用。
这里我们列出来，仅仅出于方便解释的目的。）



<p>
对于全局变量 <code>x = val</code> 的赋值等价于
<code>_ENV.x = val</code>
（参见 <a href="#2.2">&sect;2.2</a>）。





<h3>3.3.4 &ndash; <a name="3.3.4">控制结构</a></h3><p>
<b>if</b>, <b>while</b>, and <b>repeat</b>
这些控制结构符合通常的意义，而且也有类似的语法：




<pre>
	stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
	stat ::= <b>repeat</b> block <b>until</b> exp
	stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b>
</pre><p>
Lua 也有一个 <b>for</b> 语句，它有两种形式
（参见 <a href="#3.3.5">&sect;3.3.5</a>）。


<p>
控制结构中的条件表达式可以返回任何值。
<b>false</b> 与 <b>nil</b> 两者都被认为是假。
所有不同于 <b>nil</b> 与 <b>false</b> 的其它值都被认为是真
（特别需要注意的是，数字 0 和空字符串也被认为是真）。


<p>
在 <b>repeat</b>&ndash;<b>until</b> 循环中，
内部语句块的结束点不是在 <b>until</b> 这个关键字处，
它还包括了其后的条件表达式。
因此，条件表达式中可以使用循环内部语句块中的定义的局部变量。


<p>
<b>goto</b> 语句将程序的控制点转移到一个标签处。
由于句法上的原因，
Lua 里的标签也被认为是语句：



<pre>
	stat ::= <b>goto</b> Name
	stat ::= label
	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;
</pre>

<p>
除了在内嵌函数中，以及在内嵌语句块中定义了同名标签，的情况外，
标签对于它定义所在的整个语句块可见。
只要 goto 没有进入一个新的局部变量的作用域，它可以跳转到任意可见标签处。


<p>
标签和没有内容的语句被称为<em>空语句</em>，它们不做任何操作。


<p>
<b>break</b> 被用来结束
<b>while</b>、 <b>repeat</b>、或 <b>for</b> 循环，
它将跳到循环外接着之后的语句运行：


<pre>
	stat ::= <b>break</b>
</pre><p>
<b>break</b> 跳出最内层的循环。


<p>
<b>return</b> 被用于从函数或是代码块（其实它就是一个函数）
中返回值。

函数可以返回不只一个值，所以 <b>return</b> 的语法为

<pre>
	stat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]
</pre>

<p>
<b>return</b> 只能被写在一个语句块的最后一句。
如果你真的需要从语句块的中间 <b>return</b>，
你可以使用显式的定义一个内部语句块，
一般写作 <code>do return end</code>。
可以这样写是因为现在 <b>return</b> 成了（内部）语句块的最后一句了。





<h3>3.3.5 &ndash; <a name="3.3.5">For 语句</a></h3>

<p>
<b>for</b> 有两种形式：一种是数字形式，另一种是通用形式。


<p>
数字形式的 <b>for</b> 循环，通过一个数学运算不断地运行内部的代码块。
下面是它的语法：

<pre>
	stat ::= <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b>
</pre><p>
<em>block</em> 将把 <em>name</em> 作循环变量。
从第一个 <em>exp</em> 开始起，直到第二个 <em>exp</em> 的值为止，
其步长为第三个 <em>exp</em> 。
更确切的说，一个 <b>for</b> 循环看起来是这个样子

<pre>
     for v = <em>e1</em>, <em>e2</em>, <em>e3</em> do <em>block</em> end
</pre><p>
这等价于代码：

<pre>
     do
       local <em>var</em>, <em>limit</em>, <em>step</em> = tonumber(<em>e1</em>), tonumber(<em>e2</em>), tonumber(<em>e3</em>)
       if not (<em>var</em> and <em>limit</em> and <em>step</em>) then error() end
       <em>var</em> = <em>var</em> - <em>step</em>
       while true do
         <em>var</em> = <em>var</em> + <em>step</em>
         if (<em>step</em> &gt;= 0 and <em>var</em> &gt; <em>limit</em>) or (<em>step</em> &lt; 0 and <em>var</em> &lt; <em>limit</em>) then
           break
         end
         local v = <em>var</em>
         <em>block</em>
       end
     end
</pre>

<p>
注意下面这几点：

<ul>

<li>
所有三个控制表达式都只被运算一次，
表达式的计算在循环开始之前。 
这些表达式的结果必须是数字。
</li>

<li>
<code><em>var</em></code>，<code><em>limit</em></code>，以及 <code><em>step</em></code>
都是一些不可见的变量。 
这里给它们起的名字都仅仅用于解释方便。
</li>

<li>
如果第三个表达式（步长）没有给出，会把步长设为 1 。
</li>

<li>
你可以用 <b>break</b> 和 <b>goto</b> 来退出 <b>for</b> 循环。
</li>

<li>
循环变量 <code>v</code> 是一个循环内部的局部变量；
如果你需要在循环结束后使用这个值，
在退出循环前把它赋给另一个变量。
</li>

</ul>

<p>
通用形式的 <b>for</b> 通过一个叫作 <em>迭代器</em> 的函数工作。
每次迭代，迭代器函数都会被调用以产生一个新的值，
当这个值为 <b>nil</b> 时，循环停止。 
通用形式的 <b>for</b> 循环的语法如下：

<pre>
	stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}
</pre><p>
这样的 <b>for</b> 语句

<pre>
     for <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> in <em>explist</em> do <em>block</em> end
</pre><p>
它等价于这样一段代码：

<pre>
     do
       local <em>f</em>, <em>s</em>, <em>var</em> = <em>explist</em>
       while true do
         local <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> = <em>f</em>(<em>s</em>, <em>var</em>)
         if <em>var_1</em> == nil then break end
         <em>var</em> = <em>var_1</em>
         <em>block</em>
       end
     end
</pre><p>
注意以下几点：

<ul>

<li>
<code><em>explist</em></code> 只会被计算一次。
它返回三个值， 一个 <em>迭代器</em> 函数，
一个 <em>状态</em>，
一个 <em>迭代器的初始值</em>。
</li>

<li>
<code><em>f</em></code>， <code><em>s</em></code>，与 <code><em>var</em></code>
都是不可见的变量。
这里给它们起的名字都只是为了解说方便。
</li>

<li>
你可以使用 <b>break</b> 来跳出 <b>for</b> 循环。
</li>

<li>
环变量 <code><em>var_i</em></code> 对于循环来说是一个局部变量；
你不可以在 <b>for</b> 循环结束后继续使用。
如果你需要保留这些值，那么就在循环跳出或结束前赋值到别的变量里去。
</li>

</ul>




<h3>3.3.6 &ndash; <a name="3.3.6">函数调用语句</a></h3><p>
为了允许使用函数的副作用，
函数调用可以被作为一个语句执行：

<pre>
	stat ::= functioncall
</pre><p>
在这种情况下，所有的返回值都被舍弃。
函数调用在 <a href="#3.4.10">&sect;3.4.10</a> 中解释。





<h3>3.3.7 &ndash; <a name="3.3.7">局部声明</a></h3><p>
局部变量可以在语句块中任何地方声明。 
声明可以包含一个初始化赋值操作：


<pre>
	stat ::= <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist]
</pre><p>
如果有初始化值的话，初始化赋值操作的语法和赋值操作一致
（参见 <a href="#3.3.3">&sect;3.3.3</a> ）。
若没有初始化值，所有的变量都被初始化为 <b>nil</b>。



<p>
一个代码块同时也是一个语句块（参见 <a href="#3.3.2">&sect;3.3.2</a>），
所以局部变量可以放在代码块中那些显式注明的语句块之外。 


<p>
局部变量的可见性规则在 <a href="#3.5">&sect;3.5</a> 中解释。







<h2>3.4 &ndash; <a name="3.4">表达式</a></h2>

<p>
Lua 中有这些基本表达式：

<pre>
	exp ::= prefixexp
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Numeral
	exp ::= LiteralString
	exp ::= functiondef
	exp ::= tableconstructor
	exp ::= &lsquo;<b>...</b>&rsquo;
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;
</pre>

<p>
数字和字面串在 <a href="#3.1">&sect;3.1</a> 中解释；
变量在 <a href="#3.2">&sect;3.2</a> 中解释；
函数定义在 <a href="#3.4.11">&sect;3.4.11</a> 中解释；
函数调用在 <a href="#3.4.10">&sect;3.4.10</a> 中解释；
表的构造在 <a href="#3.4.9">&sect;3.4.9</a> 中解释。
可变参数的表达式写作三个点（'<code>...</code>'），
它只能在有可变参数的函数中直接使用；这些在 <a href="#3.4.11">&sect;3.4.11</a> 中解释。


<p>
二元操作符包含有数学运算操作符（参见 <a href="#3.4.1">&sect;3.4.1</a>），
位操作符（参见 <a href="#3.4.2">&sect;3.4.2</a>），
比较操作符（参见 <a href="#3.4.4">&sect;3.4.4</a>），
逻辑操作符（参见 <a href="#3.4.5">&sect;3.4.5</a>），
以及连接操作符（参见 <a href="#3.4.6">&sect;3.4.6</a>）。
一元操作符包括负号（参见 <a href="#3.4.1">&sect;3.4.1</a>），
按位非（参见 <a href="#3.4.2">&sect;3.4.2</a>），
逻辑非（参见 <a href="#3.4.5">&sect;3.4.5</a>），
和取长度操作符（参见 <a href="#3.4.7">&sect;3.4.7</a>）。



<p>
函数调用和可变参数表达式都可以放在多重返回值中。 
如果函数调用被当作一条语句（参见 <a href="#3.3.6">&sect;3.3.6</a>），
其返回值列表被调整为零个元素，即抛弃所有的返回值。
如果表达式被用于表达式列表的最后（或是唯一的）一个元素，
那么不会做任何调整（除非表达式被括号括起来）。
在其它情况下，
Lua 都会把结果调整为一个元素置入表达式列表中，
即保留第一个结果而忽略之后的所有值，或是在没有结果时，
补单个 <b>nil</b>。


<p>
这里有一些例子：

<pre>
     f()                -- 调整为 0 个结果
     g(f(), x)          -- f() 会被调整为一个结果
     g(x, f())          -- g 收到 x 以及 f() 返回的所有结果
     a,b,c = f(), x     -- f() 被调整为 1 个结果 （c 收到 nil）
     a,b = ...          -- a 收到可变参数列表的第一个参数，
                        -- b 收到第二个参数（如果可变参数列表中
                        -- 没有实际的参数，a 和 b 都会收到 nil）
     
     a,b,c = x, f()     -- f() 被调整为 2 个结果
     a,b,c = f()        -- f() 被调整为 3 个结果
     return f()         -- 返回 f() 的所有返回结果
     return ...         -- 返回从可变参数列表中接收到的所有参数parameters
     return x,y,f()     -- 返回 x, y, 以及 f() 的所有返回值
     {f()}              -- 用 f() 的所有返回值创建一个列表
     {...}              -- 用可变参数中的所有值创建一个列表
     {f(), nil}         -- f() 被调整为一个结果
</pre>

<p>
被括号括起来的表达式永远被当作一个值。
所以，
<code>(f(x,y,z))</code> 即使 <code>f</code> 返回多个值，
这个表达式永远是一个单一值。 
（<code>(f(x,y,z))</code> 的值是 <code>f</code> 返回的第一个值。
如果 <code>f</code> 不返回值的话，那么它的值就是 <b>nil</b> 。）



<h3>3.4.1 &ndash; <a name="3.4.1">数学运算操作符</a></h3><p>
Lua 支持下列数学运算操作符：

<ul>
<li><b><code>+</code>: </b>加法</li>
<li><b><code>-</code>: </b>减法</li>
<li><b><code>*</code>: </b>乘法</li>
<li><b><code>/</code>: </b>浮点除法</li>
<li><b><code>//</code>: </b>向下取整除法</li>
<li><b><code>%</code>: </b>取模</li>
<li><b><code>^</code>: </b>乘方</li>
<li><b><code>-</code>: </b>取负</li>
</ul>

<p>
除了乘方和浮点除法运算，
数学运算按如下方式工作：
如果两个操作数都是整数，
该操作以整数方式操作且结果也将是一个整数。
否则，当两个操作数都是数字或可以被转换为数字的字符串
（参见 <a href="#3.4.3">&sect;3.4.3</a>）时，
操作数会被转换成两个浮点数，
操作按通常的浮点规则（一般遵循 IEEE 754 标准）
来进行，结果也是一个浮点数。


<p>
乘方和浮点除法 （<code>/</code>）
总是把操作数转换成浮点数进行，起结果总是浮点数。
乘方使用 ISO C 函数 <code>pow</code>，
因此它也可以接受非整数的指数。


<p>
向下取整的除法 （<code>//</code>）
指做一次除法，并将商圆整到靠近负无穷的一侧，
即对操作数做除法后取 floor 。


<p>
取模被定义成除法的余数，其商被圆整到靠近负无穷的一侧（向下取整的除法）。


<p>
对于整数数学运算的溢出问题，
这些操作采取的策略是按通常遵循的以 2 为补码的数学运算的 <em>环绕</em> 规则。
（换句话说，它们返回其运算的数学结果对 <em>2<sup>64</sup></em> 取模后的数字。）



<h3>3.4.2 &ndash; <a name="3.4.2">位操作符</a></h3><p>
Lua 支持下列位操作符：

<ul>
<li><b><code>&amp;</code>: </b>按位与</li>
<li><b><code>&#124;</code>: </b>按位或</li>
<li><b><code>~</code>: </b>按位异或</li>
<li><b><code>&gt;&gt;</code>: </b>右移</li>
<li><b><code>&lt;&lt;</code>: </b>左移</li>
<li><b><code>~</code>: </b>按位非</li>
</ul>

<p>
所有的位操作都将操作数先转换为整数
（参见 <a href="#3.4.3">&sect;3.4.3</a>），
然后按位操作，其结果是一个整数。


<p>
对于右移和左移，均用零来填补空位。
移动的位数若为负，则向反方向位移；
若移动的位数的绝对值大于等于
整数本身的位数，其结果为零
（所有位都被移出）。





<h3>3.4.3 &ndash; <a name="3.4.3">强制转换</a></h3><p>
Lua 对一些类型和值的内部表示会在运行时做一些数学转换。
位操作总是将浮点操作数转换成整数。
乘方和浮点除法总是将整数转换为浮点数。
其它数学操作若针对混合操作数
（整数和浮点数）将把整数转换为浮点数；
这一点被称为 <em>通常规则</em>。
C API 同样会按需把整数转换为浮点数以及
把浮点数转换为整数。
此外，字符串连接操作除了字符串，也可以接受数字作为参数。


<p>
当操作需要数字时，Lua 还会把字符串转换为数字。


<p>
当把一个整数转换为浮点数时，
若整数值恰好可以表示为一个浮点数，那就取那个浮点数。
否则，转换会取最接近的较大值或较小值来表示这个数。
这种转换是不会失败的。


<p>
将浮点数转为整数的过程会检查
浮点数能否被准确的表达为一个整数
（即，浮点数是一个整数值且在整数可以表达的区间）。
如果可以，结果就是那个数，否则转换失败。


<p>
从字符串到数字的转换过程遵循以下流程：
首先，遵循按 Lua 词法分析器的规则分析语法来转换为对应的
整数或浮点数。
（字符串可以有前置或后置的空格以及一个符号。）
然后，结果数字再按前述副转换为所需要的类型（浮点或整数）。


<p>
从数字转换为字符串使用非制定的人可读的格式。
若想完全控制数字到字符串的转换过程，
可以使用字符串库中的 <code>format</code> 函数
（参见 <a href="#pdf-string.format"><code>string.format</code></a>）。





<h3>3.4.4 &ndash; <a name="3.4.4">比较操作符</a></h3><p>
Lua 支持下列比较操作符：

<ul>
<li><b><code>==</code>: </b>等于</li>
<li><b><code>~=</code>: </b>不等于</li>
<li><b><code>&lt;</code>: </b>小于</li>
<li><b><code>&gt;</code>: </b>大于</li>
<li><b><code>&lt;=</code>: </b>小于等于</li>
<li><b><code>&gt;=</code>: </b>大于等于</li>
</ul><p>
这些操作的结果不是 <b>false</b> 就是 <b>true</b>。


<p>
等于操作 （<code>==</code>）先比较操作数的类型。
如果类型不同，结果就是 <b>false</b>。
否则，继续比较值。 
字符串按一般的方式比较。
数字遵循二元操作的规则：
如果两个操作数都是整数，
它们按整数比较；
否则，它们先转换为浮点数，然后再做比较。


<p>
表，用户数据，以及线程都按引用比较：
只有两者引用同一个对象时才认为它们相等。
每次你创建一个新对象（一张表，一个用户数据，或一个线程），
新对象都一定和已有且存在的对象不同。
相同引用的闭包一定相等。
有任何可察觉的差异（不同的行为，不同的定义）一定不等。


<p>
你可以通过使用 "eq" 元方法（参见 <a href="#2.4">&sect;2.4</a>）
来改变 Lua 比较表和用户数据时的方式。


<p>
等于操作不会将字符串转换为数字，反之亦然。
即，<code>"0"==0</code> 结果为 <b>false</b>，
且 <code>t[0]</code> 与 <code>t["0"]</code> 指代着表中的不同项。


<p>
<code>~=</code> 操作完全等价于 (<code>==</code>) 操作的反值。


<p>
大小比较操作以以下方式进行。
如果参数都是数字，
它们按二元操作的常规进行。
否则，如果两个参数都是字符串，
它们的值按当前的区域设置来比较。
再则，Lua 就试着调用 "lt" 或是 "le" 元方法
（参见 <a href="#2.4">&sect;2.4</a>）。
<code>a &gt; b</code> 的比较被转译为 <code>b &lt; a</code>，
<code>a &gt;= b</code> 被转译为 <code>b &lt;= a</code>。





<h3>3.4.5 &ndash; <a name="3.4.5">逻辑操作符</a></h3><p>
Lua 中的逻辑操作符有 <b>and</b>， <b>or</b>，以及 <b>not</b>。
和控制结构（参见 <a href="#3.3.4">&sect;3.3.4</a>）一样，
所有的逻辑操作符把 <b>false</b> 和 <b>nil</b> 都作为假，
而其它的一切都当作真。


<p>
取反操作 <b>not</b> 总是返回 <b>false</b> 或 <b>true</b> 中的一个。
与操作符 <b>and</b> 在第一个参数为 <b>false</b> 或 <b>nil</b> 时
返回这第一个参数；
否则，<b>and</b> 返回第二个参数。 
或操作符 <b>or</b> 在第一个参数不为 <b>nil</b> 也不为 <b>false</b> 时，
返回这第一个参数，否则返回第二个参数。
<b>and</b> 和 <b>or</b> 都遵循短路规则；
也就是说，第二个操作数只在需要的时候去求值。
这里有一些例子：

<pre>
     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</pre><p>
（在这本手册中，
<code>--&gt;</code> 指前面表达式的结果。）





<h3>3.4.6 &ndash; <a name="3.4.6">字符串连接</a></h3><p>
Lua 中字符串的连接操作符写作两个点（'<code>..</code>'）。
如果两个操作数都是字符串或都是数字，
连接操作将以 <a href="#3.4.3">&sect;3.4.3</a> 中提到的规则把其转换为字符串。
否则，会调用元方法 <code>__concat</code> （参见 <a href="#2.4">&sect;2.4</a>）。





<h3>3.4.7 &ndash; <a name="3.4.7">取长度操作符</a></h3>

<p>
取长度操作符写作一元前置符 <code>#</code>。
字符串的长度是它的字节数（就是以一个字符一个字节计算的字符串长度）。


<p>
程序可以通过 <code>__len</code> 元方法（参见 <a href="#2.4">&sect;2.4</a>）
来修改对字符串类型外的任何值的取长度操作行为。


<p>
如果 <code>__len</code> 元方法没有给出，
表 <code>t</code> 的长度只在表是一个 <em>序列</em> 时有定义。
序列指表的正数键集等于 <em>{1..n}</em> ，
其中 <em>n</em> 是一个非负整数。
在这种情况下，<em>n</em> 是表的长度。
注意这样的表

<pre>
     {10, 20, nil, 40}
</pre><p>
不是一个序列，因为它有键 <code>4</code>
却没有键 <code>3</code>。
（因此，该表的正整数键集不等于 <em>{1..n}</em> 集合，故而就不存在 <em>n</em>。）
注意，一张表是否是一个序列和它的非数字键无关。





<h3>3.4.8 &ndash; <a name="3.4.8">优先级</a></h3><p>
Lua 中操作符的优先级写在下表中，从低到高优先级排序：

<pre>
     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     |
     ~
     &amp;
     &lt;&lt;    &gt;&gt;
     ..
     +     -
     *     /     //    %
     unary operators (not   #     -     ~)
     ^
</pre><p>
通常，
你可以用括号来改变运算次序。
连接操作符 ('<code>..</code>') 和乘方操作 ('<code>^</code>') 
是从右至左的。 
其它所有的操作都是从左至右。




<h3>3.4.9 &ndash; <a name="3.4.9">表构建</a></h3><p>
表构造子是一个构造表的表达式。
每次构造子被执行，都会构造出一张新的表。
构造子可以被用来构造一张空表，
也可以用来构造一张表并初始化其中的一些域。
一般的构造子的语法如下

<pre>
	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp
	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;
</pre>

<p>
每个形如 <code>[exp1] = exp2</code> 的域向表中增加新的一项，
其键为 <code>exp1</code> 而值为 <code>exp2</code>。
形如 <code>name = exp</code> 的域等价于
<code>["name"] = exp</code>。
最后，形如 <code>exp</code> 的域等价于 <code>[i] = exp</code> ，
这里的 <code>i</code> 是一个从 1 开始不断增长的数字。
这这个格式中的其它域不会破坏其记数。
举个例子：

<pre>
     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre><p>
等价于

<pre>
     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- 1st exp
       t[2] = "y"         -- 2nd exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- 3rd exp
       t[30] = 23
       t[4] = 45          -- 4th exp
       a = t
     end
</pre>

<p>
构造子中赋值的次序未定义。
（次序问题只会对那些键重复时的情况有影响。）


<p>
如果表单中最后一个域的形式是 <code>exp</code> ，
而且其表达式是一个函数调用或者是一个可变参数，
那么这个表达式所有的返回值将依次进入列表 
（参见 <a href="#3.4.10">&sect;3.4.10</a>）。


<p>
初始化域表可以在最后多一个分割符，
这样设计可以方便由机器生成代码。




<h3>3.4.10 &ndash; <a name="3.4.10">函数调用</a></h3><p>
Lua 中的函数调用的语法如下：

<pre>
	functioncall ::= prefixexp args
</pre><p>
数调用时，
第一步，prefixexp 和 args 先被求值。
如果 prefixexp 的值的类型是 <em>function</em>，
那么这个函数就被用给出的参数调用。
否则 prefixexp 的元方法 "call" 就被调用，
第一个参数是 prefixexp 的值，
接下来的是原来的调用参数 
（参见 <a href="#2.4">&sect;2.4</a>）。


<p>
这样的形式

<pre>
	functioncall ::= prefixexp &lsquo;<b>:</b>&rsquo; Name args
</pre><p>
可以用来调用 "方法"。
这是 Lua 支持的一种语法糖。
像 <code>v:name(args)</code> 这个样子，
被解释成 <code>v.name(v,args)</code>，
这里的 <code>v</code> 只会被求值一次。


<p>
参数的语法如下：

<pre>
	args ::= &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo;
	args ::= tableconstructor
	args ::= LiteralString
</pre><p>
所有参数的表达式求值都在函数调用之前。
这样的调用形式 <code>f{fields}</code> 是一种语法糖用于表示
<code>f({fields})</code>；
这里指参数列表是一个新创建出来的列表。
而这样的形式 <code>f'<em>string</em>'</code>
（或是 <code>f"<em>string</em>"</code> 亦或是 <code>f[[<em>string</em>]]</code>）
也是一种语法糖，用于表示 <code>f('<em>string</em>')</code>；
此时的参数列表是一个单独的字符串。


<p>
<code>return <em>functioncall</em></code> 
这样的调用形式将触发一次 <em>尾调用</em>。
Lua 实现了 <em>完全尾调用</em>（或称为 <em>完全尾递归</em>）：
在尾调用中， 被调用的函数重用调用它的函数的堆栈项。
因此，对于程序执行的嵌套尾调用的层数是没有限制的。
然而，尾调用将删除调用它的函数的任何调试信息。
注意，尾调用只发生在特定的语法下，
仅当 <b>return</b> 只有单一函数调用作为参数时才发生尾调用；
这种语法使得调用函数的所有结果可以完整地返回。
因此，下面这些例子都不是尾调用：

<pre>
     return (f(x))        -- 返回值被调整为一个
     return 2 * f(x)
     return x, f(x)       -- 追加若干返回值
     f(x); return         -- 返回值全部被舍弃
     return x or f(x)     -- 返回值被调整为一个
</pre>




<h3>3.4.11 &ndash; <a name="3.4.11">函数定义</a></h3>

<p>
函数定义的语法如下：

<pre>
	functiondef ::= <b>function</b> funcbody
	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>
</pre>

<p>
另外定义了一些语法糖简化函数定义的写法：

<pre>
	stat ::= <b>function</b> funcname funcbody
	stat ::= <b>local</b> <b>function</b> Name funcbody
	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]
</pre><p>
该语句

<pre>
     function f () <em>body</em> end
</pre><p>
被转译成

<pre>
     f = function () <em>body</em> end
</pre><p>
该语句

<pre>
     function t.a.b.c.f () <em>body</em> end
</pre><p>
被转译成

<pre>
     t.a.b.c.f = function () <em>body</em> end
</pre><p>
该语句

<pre>
     local function f () <em>body</em> end
</pre><p>
被转译成

<pre>
     local f; f = function () <em>body</em> end
</pre><p>
而不是

<pre>
     local f = function () <em>body</em> end
</pre><p>
（这个差别只在函数体内需要引用 <code>f</code> 时才有。）


<p>
一个函数定义是一个可执行的表达式，
执行结果是一个类型为 <em>function</em> 的值。
当 Lua 预编译一个代码块时，
代码块作为一个函数，整个函数体也就被预编译了。
那么，无论何时 Lua 执行了函数定义，
这个函数本身就进行了 <em>实例化</em>（或者说是 <em>关闭</em>了）。
这个函数的实例（或者说是 <em>闭包</em>）是表达式的最终值。

<p>
形参被看作是一些局部变量，
它们将由实参的值来初始化：

<pre>
	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;
</pre><p>
当一个函数被调用，
如果函数并非一个 <em>可变参数函数</em>，
即在形参列表的末尾注明三个点 ('<code>...</code>')，
那么实参列表就会被调整到形参列表的长度。
变长参数函数不会调整实参列表； 
取而代之的是，它将把所有额外的参数放在一起通过
<em>变长参数表达式</em>传递给函数，
其写法依旧是三个点。
这个表达式的值是一串实参值的列表，
看起来就跟一个可以返回多个结果的函数一样。
如果一个变长参数表达式放在另一个表达式中使用，
或是放在另一串表达式的中间，
那么它的返回值就会被调整为单个值。
若这个表达式放在了一系列表达式的最后一个，
就不会做调整了
（除非这最后一个参数被括号给括了起来）。


<p>
我们先做如下定义，然后再来看一个例子：

<pre>
     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</pre><p>
下面看看实参到形参数以及可变长参数的映射关系：

<pre>
     CALL            PARAMETERS
     
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
     
     g(3)             a=3, b=nil, ... --&gt;  (nothing)
     g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3
</pre>

<p>
结果由 <b>return</b> 来返回（参见 <a href="#3.3.4">&sect;3.3.4</a>）。
如果执行到函数末尾依旧没有遇到任何 <b>return</b> 语句，
函数就不会返回任何结果。


<p>
关于函数可返回值的数量限制和系统有关。
这个限制一定大于 1000 。


<p>
<em>冒号</em> 语法可以用来定义 <em>方法</em>，
就是说，函数可以有一个隐式的形参 <code>self</code>。
因此，如下语句

<pre>
     function t.a.b.c:f (<em>params</em>) <em>body</em> end
</pre><p>
是这样一种写法的语法糖

<pre>
     t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end
</pre>






<h2>3.5 &ndash; <a name="3.5">可见性规则</a></h2>

<p>
Lua 语言有词法作用范围。
变量的作用范围开始于声明它们之后的第一个语句段，
结束于包含这个声明的最内层语句块的最后一个非空语句。
看下面这些例子：

<pre>
     x = 10                -- 全局变量
     do                    -- 新的语句块
       local x = x         -- 新的一个 'x', 它的值现在是 10
       print(x)            --&gt; 10
       x = x+1
       do                  -- 另一个语句块
         local x = x+1     -- 又一个 'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10 （取到的是全局的那一个）
</pre>

<p>
注意这里，类似 <code>local x = x</code> 这样的声明，
新的 <code>x</code> 正在被声明，但是还没有进入它的作用范围，
所以第二个 <code>x</code> 指向的是外面一层的变量。


<p>
因为有这样一个词法作用范围的规则，
局部变量可以被在它的作为范围内定义的函数自由使用。
当一个局部变量被内层的函数中使用的时候，
它被内层函数称作 <em>上值</em>，或是 <em>外部局部变量</em>。


<p>
注意，每次执行到一个 <b>local</b> 语句都会定义出一个新的局部变量。
看看这样一个例子：

<pre>
     a = {}
     local x = 20
     for i=1,10 do
       local y = 0
       a[i] = function () y=y+1; return x+y end
     end
</pre><p>
这个循环创建了十个闭包（这指十个匿名函数的实例）。
这些闭包中的每一个都使用了不同的 <code>y</code> 变量，
而它们又共享了同一份 <code>x</code>。




<h1>4 &ndash; <a name="4">编程接口</a></h1>

<p>
这个部分描述了 Lua 的 C API ，
也就是宿主程序跟 Lua 通讯用的一组 C 函数。 
所有的 API 函数按相关的类型以及常量都声明在头文件 
<a name="pdf-lua.h"><code>lua.h</code></a> 中。


<p>
虽然我们说的是“函数”，
但一部分简单的 API 是以宏的形式提供的。 
除非另有说明，
所有的这些宏都只使用它们的参数一次 
（除了第一个参数，那一定是 Lua 状态），
因此你不需担心这些宏的展开会引起一些副作用。


<p>
C 库中所有的 Lua API 函数都不去检查参数是否相容及有效。
然而，你可以在编译 Lua 时加上打开一个宏开关
<a name="pdf-LUA_USE_APICHECK"><code>LUA_USE_APICHECK</code></a>
来改变这个行为。


<h2>4.1 &ndash; <a name="4.1">栈</a></h2>

<p>
Lua 使用一个 <em>虚拟栈</em> 来和 C 互传值。
栈上的的每个元素都是一个 Lua 值 （<b>nil</b>，数字，字符串，等等）。



<p>
无论何时 Lua 调用 C，被调用的函数都得到一个新的栈，
这个栈独立于 C 函数本身的栈，也独立于之前的 Lua 栈。
它里面包含了 Lua 传递给 C 函数的所有参数，
而 C 函数则把要返回的结果放入这个栈以返回给调用者 
（参见 <a href="#lua_CFunction"><code>lua_CFunction</code></a>）。


<p>
方便起见，
所有针对栈的 API 查询操作都不严格遵循栈的操作规则。
而是可以用一个 <em>索引</em> 来指向栈上的任何元素：
正的索引指的是栈上的绝对位置（从一开始）；
负的索引则指从栈顶开始的偏移量。
展开来说，如果堆栈有 <em>n</em> 个元素，
那么索引 1 表示第一个元素
（也就是最先被压栈的元素）
而索引 <em>n</em> 则指最后一个元素；
索引 -1 也是指最后一个元素
（即栈顶的元素）， 
索引 <em>-n</em> 是指第一个元素。




<h2>4.2 &ndash; <a name="4.2">栈大小</a></h2>

<p>
当你使用 Lua API 时，
就有责任保证做恰当的调用。 
特别需要注意的是，
<em>你有责任控制不要堆栈溢出</em>。
你可以使用 <a href="#lua_checkstack"><code>lua_checkstack</code></a>
这个函数来扩大可用堆栈的尺寸。


<p>
无论何时 Lua 调用 C ，
它都只保证至少有
<a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a>
这么多的堆栈空间可以使用。
<code>LUA_MINSTACK</code> 一般被定义为 20 ，
因此，只要你不是不断的把数据压栈，
通常你不用关心堆栈大小。


<p>
当你调用一个 Lua 函数却没有指定要接收多少个返回值时
（参见 <a href="#lua_call"><code>lua_call</code></a>），
Lua 可以保证栈一定有足够的空间来接收所有的返回值，
但不保证此外留有额外的空间。
因此，在做了一次这样的调用后，如果你需要继续压栈，
则需要使用 <a href="#lua_checkstack"><code>lua_checkstack</code></a>。




<h2>4.3 &ndash; <a name="4.3">有效索引与可接受索引</a></h2>

<p>
API 中的函数若需要传入栈索引，这个索引必须是
<em>有效索引</em> 或是 <em>可接受索引</em>。


<p>
<em>有效索引</em> 指引用栈内真实位置的索引；
即在 1 到栈顶之间的位置
（<code>1 &le; abs(index) &le; top</code>）。

通常，一个可能修改该位置的值的函数需要传入有效索引。


<p>
除非另有说明，
任何可以接受有效索引的函数同时也接受 <em>伪索引</em>。
伪索引指代一些可以被 C code 访问得到 Lua 值，而它们又不在栈内。
这用于访问注册表以及 C 函数的上值（参见 <a href="#4.4">&sect;4.4</a>）。


<p>
对于那些只是需要栈中的值（例如查询函数）
而不需要指定一个栈位置的函数，
可以用一个可接受的索引去调用它们。
<em>可接受索引</em> 不仅可以是任何包括伪索引在内的有效索引，
还可以是任何超过栈顶但落下为栈分配出来的空间内的正索引。
（注意 0 永远都不是一个可接受索引。）
除非另有说明，API 里的函数都接受可接受索引。


<p>
允许可接受索引是为了避免对栈顶以外的查询时做额外的检查。
例如，C 函数可以直接查询传给它的第三个参数，
而不用先检查是不是有第三个参数，
即不需要检查 3 是不是一个有效索引。


<p>
对于那些以可接受索引调用的函数，
无效索引被看作包含了一个虚拟类型
<a name="pdf-LUA_TNONE"><code>LUA_TNONE</code></a> 的值，
这个值的行为和 nil 一致。




<h2>4.4 &ndash; <a name="4.4">C 闭包</a></h2>

<p>
当 C 函数被创建出来，
我们有可能会把一些值关联在一起，
也就是创建一个 <em>C 闭包</em>
（参见 <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>）；
这些被关联起来的值被叫做 <em>上值</em> ，
它们可以在函数被调用的时候访问的到。 


<p>
无论何时去调用 C 函数，
函数的上值都可以用伪索引定位。
我们可以用
<a href="#lua_upvalueindex"><code>lua_upvalueindex</code></a>
这个宏来生成这些伪索引。
第一个关联到函数的值放在
<code>lua_upvalueindex(1)</code> 位置处，依此类推。 
使用 <code>lua_upvalueindex(<em>n</em>)</code> 时，
若 <em>n</em> 大于当前函数的总上值个数
（但不可以大于 256）会产生一个可接受的但无效的索引。




<h2>4.5 &ndash; <a name="4.5">注册表</a></h2>

<p>
Lua 提供了一个 <em>注册表</em>，
这是一个预定义出来的表，
可以用来保存任何 C 代码想保存的 Lua 值。 
这个表可以用有效伪索引 
<a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a> 来定位。
任何 C 库都可以在这张表里保存数据，
为了防止冲突，你需要特别小心的选择键名。
一般的用法是，你可以用一个包含你的库名的字符串做为键名，
或者取你自己 C 对象的地址，以轻量用户数据的形式做键，
还可以用你的代码创建出来的任意 Lua 对象做键。
关于变量名，字符串键名中以下划线加大写字母的名字被 Lua 保留。



<p>
注册表中的整数键用于引用机制
（参见 <a href="#luaL_ref"><code>luaL_ref</code></a>），
以及一些预定义的值。
因此，整数键不要用于别的目的。


<p>
当你创建了一个新的 Lua 状态机，
其中的注册表内就预定义好了几个值。
这些预定义值可以用整数索引到，
这些整数以常数形式定义在 <code>lua.h</code> 中。
有下列常数：

<ul>
<li><b><a name="pdf-LUA_RIDX_MAINTHREAD"><code>LUA_RIDX_MAINTHREAD</code></a>: </b>
注册表中这个索引下是状态机的主线程。
（主线程和状态机同时被创建出来。）
</li>

<li><b><a name="pdf-LUA_RIDX_GLOBALS"><code>LUA_RIDX_GLOBALS</code></a>: </b> 
注册表的这个索引下是全局环境。
</li>
</ul>




<h2>4.6 &ndash; <a name="4.6">C 中的错误处理</a></h2>

<p>
在内部实现中，Lua 使用了 C 的 <code>longjmp</code> 机制来处理错误。
（如果你使用 C++ 编译，Lua 将换成异常；
细节请在源代码中搜索 <code>LUAI_THROW</code>。）
当 Lua 碰到任何错误
（比如内存分配错误、类型错误、语法错误、还有运行时错误）
它都会 <em>抛出</em>一个错误出去；
也就是调用一次长跳转。
在 <em>保护环境</em> 下，
Lua 使用 <code>setjmp</code> 来设置一个恢复点；
任何发生的错误都会跳转到最近的一个恢复点。


<p>
如果错误发生在保护环境之外，
Lua 会先调用 <em>panic 函数</em> （参见 <a href="#lua_atpanic"><code>lua_atpanic</code></a>）
然后调用 <code>abort</code> 来退出宿主程序。
你的 panic 函数只要不返回
（例如：长跳转到你在 Lua 外你自己设置的恢复点）
就可以必须退出程序。


<p>
panic 函数以错误消息处理器（参见 <a href="#2.3">&sect;2.3</a>）的方式运行；
错误消息在栈顶。
不同的是，它不保证栈空间。
做任何压栈操作前，panic 函数都必须先检查是否有足够的空间
（参见 <a href="#4.2">&sect;4.2</a>）。


<p>
大多数 API 函数都有可能抛出错误，
例如在内存分配错误时就会抛出。
每个函数的文档都会注明它是否可能抛出错误。


<p>
在 C 函数内部，你可以通过调用 <a href="#lua_error"><code>lua_error</code></a>
来抛出错误。





<h2>4.7 &ndash; <a name="4.7">C 中的让出处理</a></h2>

<p>
Lua 内部使用 C 的 <code>longjmp</code> 机制让出一个协程。
因此，如果一个 C 函数 <code>foo</code> 调用了一个 API 函数，
而这个 API 函数让出了（直接或间接调用了让出函数）。
由于 <code>longjmp</code> 会移除 C 栈的栈帧，
Lua 就无法返回到 <code>foo</code> 里了。


<p>
为了回避这类问题，
碰到 API 调用中调用让出时，除了那些抛出错误的 API 外，还提供了三个函数：
<a href="#lua_yieldk"><code>lua_yieldk</code></a>，
<a href="#lua_callk"><code>lua_callk</code></a>，和 <a href="#lua_pcallk"><code>lua_pcallk</code></a> 。
它们在让出发生时，可以从传入的 <em>延续函数</em>
（名为 <code>k</code> 的参数）继续运行。


<p>
我们需要预设一些术语来解释延续点。
对于从 Lua 中调用的 C 函数，我们称之为 <em>原函数</em>。
从这个原函数中调用的上面所述的三个 C API 函数我们称之为 <em>被调函数</em>。
被调函数可以使当前线程让出。
（让出发生在被调函数是 <a href="#lua_yieldk"><code>lua_yieldk</code></a>，
或传入 <a href="#lua_callk"><code>lua_callk</code></a> 或
<a href="#lua_pcallk"><code>lua_pcallk</code></a> 的函数调用了让出时。）


<p>
假设正在运行的线程在执行被调函数时让出。
当再次延续这条线程，它希望继续被调函数的运行。
然而，被调函数不可能返回到原函数中。
这是因为之前的让出操作破坏了 C 栈的栈帧。
作为替代品，Lua 调用那个作为被调函数参数给出的 <em>延续函数</em> 。
正如其名，延续函数将延续原函数的任务。


<p>
下面的函数会做一个说明：

<pre>
     int original_function (lua_State *L) {
       ...     /* code 1 */
       status = lua_pcall(L, n, m, h);  /* calls Lua */
       ...     /* code 2 */
     }
</pre><p>
现在我们想允许被
<a href="#lua_pcall"><code>lua_pcall</code></a>
运行的 Lua 代码让出。
首先，我们把函数改写成这个样子：

<pre>
     int k (lua_State *L, int status, lua_KContext ctx) {
       ...  /* code 2 */
     }
     
     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcall(L, n, m, h), ctx);
     }
</pre><p>
上面的代码中，新函数 <code>k</code>
就是一个 <em>延续函数</em>
（函数类型为 <a href="#lua_KFunction"><code>lua_KFunction</code></a>）。
它的工作就是原函数中调用 <a href="#lua_pcall"><code>lua_pcall</code></a>
之后做的那些事情。
现在我们必须通知 Lua 说，你必须在被
<a href="#lua_pcall"><code>lua_pcall</code></a>
执行得 Lua 代码发生过中断（错误或让出）后，
还得继续调用 <code>k</code> 。
所以我们还得继续改写这段代码，把
<a href="#lua_pcall"><code>lua_pcall</code></a> 替换成
<a href="#lua_pcallk"><code>lua_pcallk</code></a>：


<pre>
     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcallk(L, n, m, h, ctx2, k), ctx1);
     }
</pre><p>
注意这里那个额外的显式的对延续函数的调用：
Lua 仅在需要时，这可能是由错误导致的也可能是发生了让出而需要继续运行，才会调用延续函数。
如果没有发生过任何让出，调用的函数正常返回，
那么 <a href="#lua_pcallk"><code>lua_pcallk</code></a>
（以及 <a href="#lua_callk"><code>lua_callk</code></a>）也会正常返回。
（当然，这个例子中你也可以不再之后调用延续函数，
而是在原函数的调用后直接写上需要做的工作。）


<p>
除了 Lua 状态，延续函数还有两个参数：
一个是调用最后的状态码，另一个一开始由
<a href="#lua_pcallk"><code>lua_pcallk</code></a> 传入的上下文
（<code>ctx</code>）。
（Lua 本身不使用这个值；它仅仅从原函数转发这个值给延续函数。）
对于 <a href="#lua_pcallk"><code>lua_pcallk</code></a> 而言，
状态码和 <a href="#lua_pcallk"><code>lua_pcallk</code></a>
本应返回值相同，区别仅在于发生过让出后才执行完时，状态码为
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>（而不是
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>）。
对于 <a href="#lua_yieldk"><code>lua_yieldk</code></a> 和
<a href="#lua_callk"><code>lua_callk</code></a> 而言，
调用延续函数传入的状态码一定是
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>。
（对这两个函数，Lua 不会因任何错误而调用延续函数。
因为它们并不处理错误。）
同样，当你使用 <a href="#lua_callk"><code>lua_callk</code></a> 时，
你应该用 <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>
作为状态码来调用延续函数。
（对于 <a href="#lua_yieldk"><code>lua_yieldk</code></a>，
几乎没有什么地方需要直接调用延续函数，
因为 <a href="#lua_yieldk"><code>lua_yieldk</code></a> 本身并不会返回。）


<p>
Lua 会把延续函数看作原函数。
延续函数将接收到和原函数相同的 Lua 栈，其接收到的 lua 状态也和
被调函数若返回后应该有的状态一致。
（例如，
<a href="#lua_callk"><code>lua_callk</code></a> 调用之后，
栈中之前压入的函数和调用参数都被调用产生的返回值所替代。）
这时也有相同的上值。
等到它返回的时候，Lua 会将其看待成原函数的返回去操作。





<h2>4.8 &ndash; <a name="4.8">函数和类型</a></h2>

<p>
这里按字母次序列出了所有 C API 中的函数和类型。
每个函数都有一个这样的提示：
<span class="apii">[-o, +p, <em>x</em>]</span>


<p>
对于第一个域，<code>o</code>，
指的是该函数会从栈上弹出多少个元素。
第二个域，<code>p</code>，
指该函数会将多少个元素压栈。
（所有函数都会在弹出参数后再把结果压栈。）
<code>x|y</code> 这种形式的域表示该函数根据具体情况可能压入（或弹出）
<code>x</code> 或 <code>y</code> 个元素；
问号 '<code>?</code>' 表示
我们无法仅通过参数来了解该函数会弹出/压入多少元素
（比如，数量取决于栈上有些什么）。
第三个域，<code>x</code>，
解释了该函数是否会抛出错误：
'<code>-</code>' 表示该函数绝对不会抛出错误；
'<code>e</code>' 表示该函数可能抛出错误；
'<code>v</code>' 表示该函数可能抛出有意义的错误。



<hr><h3><a name="lua_absindex"><code>lua_absindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_absindex (lua_State *L, int idx);</pre>

<p>
将一个可接受的索引 <code>idx</code> 转换为绝对索引
（即，一个不依赖栈顶在哪的值）。





<hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>
Lua 状态机中使用的内存分配器函数的类型。
内存分配函数必须提供一个功能类似于 <code>realloc</code>
但又不完全相同的函数。
它的参数有
<code>ud</code> ，一个由 <a href="#lua_newstate"><code>lua_newstate</code></a> 传给它的指针；
<code>ptr</code> ，一个指向已分配出来/将被重新分配/要释放的内存块指针；
<code>osize</code> ，内存块原来的尺寸或是关于什么将被分配出来的代码；
<code>nsize</code> ，新内存块的尺寸。 

<p>
如果 <code>ptr</code> 不是 <code>NULL</code>，
<code>osize</code> 是 <code>ptr</code> 指向的内存块的尺寸，
即这个内存块当初被分配或重分配的尺寸。


<p>
如果 <code>ptr</code> 是 <code>NULL</code>，
<code>osize</code> 是 Lua 即将分配对象类型的编码。
当（且仅当）Lua 创建一个对应类型的新对象时，
<code>osize</code> 是
<a href="#pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>，<a href="#pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>，<a href="#pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>，
<a href="#pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>，或 <a href="#pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a> 中的一个。
若 <code>osize</code> 是其它类型，Lua 将为其它东西分配内存。


<p>
Lua 假定分配器函数会遵循以下行为：


<p>
当 <code>nsize</code> 是零时，
分配器必须和 <code>free</code> 行为类似并返回 <code>NULL</code>。


<p>
当 <code>nsize</code> 不是零时，
分配器必须和 <code>realloc</code> 行为类似。
如果分配器无法完成请求，返回 <code>NULL</code>。
Lua 假定在 <code>osize &gt;= nsize</code> 成立的条件下，
分配器绝不会失败。


<p>
这里有一个简单的分配器函数的实现。
这个实现被放在补充库中，供
<a href="#luaL_newstate"><code>luaL_newstate</code></a> 使用。

<pre>
     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* not used */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</pre><p>
注意，标准 C 能确保 <code>free(NULL)</code> 没有副作用，
且 <code>realloc(NULL,size)</code> 等价于 <code>malloc(size)</code>。
这段代码假定 <code>realloc</code> 在缩小块长度时不会失败。
（虽然标准 C 没有对此行为做出保证，但这看起来是一个安全的假定。）





<hr><h3><a name="lua_arith"><code>lua_arith</code></a></h3><p>
<span class="apii">[-(2|1), +1, <em>e</em>]</span>
<pre>void lua_arith (lua_State *L, int op);</pre>

<p>
对栈顶的两个值（或者一个，比如取反）做一次数学或位操作。
其中，栈顶的那个值是第二个操作数。
它会弹出压入的值，并把结果放在栈顶。
这个函数遵循 Lua 对应的操作符运算规则
（即有可能触发元方法）。


<p>
<code>op</code> 的值必须是下列常量中的一个：

<ul>

<li><b><a name="pdf-LUA_OPADD"><code>LUA_OPADD</code></a>: </b> 加法 (<code>+</code>)</li>
<li><b><a name="pdf-LUA_OPSUB"><code>LUA_OPSUB</code></a>: </b> 减法 (<code>-</code>)</li>
<li><b><a name="pdf-LUA_OPMUL"><code>LUA_OPMUL</code></a>: </b> 乘法 (<code>*</code>)</li>
<li><b><a name="pdf-LUA_OPDIV"><code>LUA_OPDIV</code></a>: </b> 浮点除法 (<code>/</code>)</li>
<li><b><a name="pdf-LUA_OPIDIV"><code>LUA_OPIDIV</code></a>: </b> 向下取整的除法 (<code>//</code>)</li>
<li><b><a name="pdf-LUA_OPMOD"><code>LUA_OPMOD</code></a>: </b> 取模 (<code>%</code>)</li>
<li><b><a name="pdf-LUA_OPPOW"><code>LUA_OPPOW</code></a>: </b> 乘方 (<code>^</code>)</li>
<li><b><a name="pdf-LUA_OPUNM"><code>LUA_OPUNM</code></a>: </b> 取负 (一元 <code>-</code>)</li>
<li><b><a name="pdf-LUA_OPBNOT"><code>LUA_OPBNOT</code></a>: </b> 按位取反 (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPBAND"><code>LUA_OPBAND</code></a>: </b> 按位与 (<code>&amp;</code>)</li>
<li><b><a name="pdf-LUA_OPBOR"><code>LUA_OPBOR</code></a>: </b> 按位或 (<code>|</code>)</li>
<li><b><a name="pdf-LUA_OPBXOR"><code>LUA_OPBXOR</code></a>: </b> 按位异或 (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPSHL"><code>LUA_OPSHL</code></a>: </b> 左移 (<code>&lt;&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPSHR"><code>LUA_OPSHR</code></a>: </b> 右移 (<code>&gt;&gt;</code>)</li>

</ul>




<hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>
设置一个新的 panic 函数，并返回之前设置的那个。
（参见 <a href="#4.6">&sect;4.6</a>）。





<hr><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
<pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>
调用一个函数。


<p>
要调用一个函数请遵循以下协议：
首先，要调用的函数应该被压入栈；
接着，把需要传递给这个函数的参数按正序压栈；
这是指第一个参数首先压栈。
最后调用一下 <a href="#lua_call"><code>lua_call</code></a>；
<code>nargs</code> 是你压入栈的参数个数。
当函数调用完毕后，所有的参数以及函数本身都会出栈。
而函数的返回值这时则被压栈。
返回值的个数将被调整为 <code>nresults</code> 个，
除非 <code>nresults</code> 被设置成 <a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a>。
在这种情况下，所有的返回值都被压入堆栈中。 
Lua 会保证返回值都放入栈空间中。
函数返回值将按正序压栈（第一个返回值首先压栈），
因此在调用结束后，最后一个返回值将被放在栈顶。

<p>
被调用函数内发生的错误将（通过 <code>longjmp</code> ）一直上抛。

<p>
下面的例子中，这行 Lua 代码等价于在宿主程序中用 C 代码做一些工作：

<pre>
     a = f("how", t.x, 14)
</pre><p>
这里是 C 里的代码：

<pre>
     lua_getglobal(L, "f");                  /* function to be called */
     lua_pushliteral(L, "how");                       /* 1st argument */
     lua_getglobal(L, "t");                    /* table to be indexed */
     lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */
     lua_remove(L, -2);                  /* remove 't' from the stack */
     lua_pushinteger(L, 14);                          /* 3rd argument */
     lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */
     lua_setglobal(L, "a");                         /* set global 'a' */
</pre><p>
注意上面这段代码是 <em>平衡</em> 的：
到了最后，堆栈恢复成原有的配置。
这是一种良好的编程习惯。




<hr><h3><a name="lua_callk"><code>lua_callk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
<pre>void lua_callk (lua_State *L,
                int nargs,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
这个函数的行为和 <a href="#lua_call"><code>lua_call</code></a>
完全一致，只不过它还允许被调用的函数让出
（参见 <a href="#4.7">&sect;4.7</a>）。





<hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>
C 函数的类型。


<p>
为了正确的和 Lua 通讯，
C 函数必须使用下列协议。
这个协议定义了参数以及返回值传递方法：
C 函数通过 Lua 中的栈来接受参数，
参数以正序入栈（第一个参数首先入栈）。
因此，当函数开始的时候，
<code>lua_gettop(L)</code> 可以返回函数收到的参数个数。
第一个参数（如果有的话）在索引 1 的地方，
而最后一个参数在索引 <code>lua_gettop(L)</code> 处。 
当需要向 Lua 返回值的时候，
C 函数只需要把它们以正序压到堆栈上（第一个返回值最先压入），
然后返回这些返回值的个数。
在这些返回值之下的，堆栈上的东西都会被 Lua 丢掉。
和 Lua 函数一样，从 Lua 中调用 C 函数也可以有很多返回值。

<p>
下面这个例子中的函数将接收若干数字参数，并返回它们的平均数与和：

<pre>
     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* 参数的个数 */
       lua_Number sum = 0.0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushliteral(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* 第一个返回值 */
       lua_pushnumber(L, sum);         /* 第二个返回值 */
       return 2;                   /* 返回值的个数 */
     }
</pre>




<hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_checkstack (lua_State *L, int n);</pre>

<p>
确保堆栈上至少有 <code>n</code> 个额外空位。
如果不能把堆栈扩展到相应的尺寸，函数返回假。
失败的原因包括将把栈扩展到比固定最大尺寸还大
（至少是几千个元素）或分配内存失败。
这个函数永远不会缩小堆栈；
如果堆栈已经比需要的大了，那么就保持原样。




<hr><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_close (lua_State *L);</pre>

<p>
销毁指定 Lua 状态机中的所有对象
（如果有垃圾收集相关的元方法的话，会调用它们），
并且释放状态机中使用的所有动态内存。
在一些平台上，你可以不必调用这个函数， 
因为当宿主程序结束的时候，所有的资源就自然被释放掉了。
另一方面，长期运行的程序，比如一个后台程序或是一个网站服务器，
会创建出多个 Lua 状态机。那么就应该在不需要时赶紧关闭它们。




<hr><h3><a name="lua_compare"><code>lua_compare</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_compare (lua_State *L, int index1, int index2, int op);</pre>

<p>
比较两个 Lua 值。
当索引 <code>index1</code> 处的值通过 <code>op</code>
和索引 <code>index2</code> 处的值做比较后条件满足，函数返回 1 。
这个函数遵循 Lua 对应的操作规则（即有可能触发元方法）。
反之，函数返回 0。
当任何一个索引无效时，函数也会返回 0 。


<p>
<code>op</code> 值必须是下列常量中的一个：

<ul>

<li><b><a name="pdf-LUA_OPEQ"><code>LUA_OPEQ</code></a>: </b> 相等比较 (<code>==</code>)</li>
<li><b><a name="pdf-LUA_OPLT"><code>LUA_OPLT</code></a>: </b> 小于比较 (<code>&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPLE"><code>LUA_OPLE</code></a>: </b> 小于等于比较 (<code>&lt;=</code>)</li>

</ul>




<hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_concat (lua_State *L, int n);</pre>

<p>
连接栈顶的 <code>n</code> 个值，
然后将这些值出栈，并把结果放在栈顶。
如果 <code>n</code> 为 1 ，结果就是那个值放在栈上（即，函数什么都不做）；
如果 <code>n</code> 为 0 ，结果是一个空串。 
连接依照 Lua 中通常语义完成（参见 <a href="#3.4.6">&sect;3.4.6</a> ）。




<hr><h3><a name="lua_copy"><code>lua_copy</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_copy (lua_State *L, int fromidx, int toidx);</pre>

<p>
从索引 <code>fromidx</code> 处复制一个值到一个有效索引
<code>toidx</code> 处，覆盖那里的原有值。
不会影响其它位置的值。



<hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_createtable (lua_State *L, int narr, int nrec);</pre>

<p>
创建一张新的空表压栈。
参数 <code>narr</code> 建议了这张表作为序列使用时会有多少个元素；
参数 <code>nrec</code> 建议了这张表可能拥有多少序列之外的元素。
Lua 会使用这些建议来预分配这张新表。
如果你知道这张表用途的更多信息，预分配可以提高性能。
否则，你可以使用函数 <a href="#lua_newtable"><code>lua_newtable</code></a> 。



<hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_dump (lua_State *L,
                        lua_Writer writer,
                        void *data,
                        int strip);</pre>

<p>
把函数导出成二进制代码块 。
函数接收栈顶的 Lua 函数做参数，
然后生成它的二进制代码块。
若被导出的东西被再次加载，
加载的结果就相当于原来的函数。
当它在产生代码块的时候，
<a href="#lua_dump"><code>lua_dump</code></a>
通过调用函数 <code>writer</code>
（参见 <a href="#lua_Writer"><code>lua_Writer</code></a> ）
来写入数据，后面的 <code>data</code> 参数会被传入 <code>writer</code> 。

<p>
如果 <code>strip</code> 为真，
二进制代码块将不包含该函数的调试信息。


<p>
最后一次由 <code>writer</code> 的返回值将作为这个函数的返回值返回；
0 表示没有错误。


<p>
该函数不会把 Lua 函数弹出堆栈。



<hr><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>
<pre>int lua_error (lua_State *L);</pre>

<p>
以栈顶的值作为错误对象，抛出一个 Lua 错误。
这个函数将做一次长跳转，所以一定不会返回
（参见 <a href="#luaL_error"><code>luaL_error</code></a>）。




<hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_gc (lua_State *L, int what, int data);</pre>

<p>
控制垃圾收集器。


<p>
这个函数根据其参数 <code>what</code> 发起几种不同的任务：

<ul>

<li><b><code>LUA_GCSTOP</code>: </b>
停止垃圾收集器。
</li>

<li><b><code>LUA_GCRESTART</code>: </b>
重启垃圾收集器。
</li>

<li><b><code>LUA_GCCOLLECT</code>: </b>
发起一次完整的垃圾收集循环。
</li>

<li><b><code>LUA_GCCOUNT</code>: </b>
返回 Lua 使用的内存总量（以 K 字节为单位）。
</li>

<li><b><code>LUA_GCCOUNTB</code>: </b>
返回当前内存使用量除以 1024 的余数。
</li>

<li><b><code>LUA_GCSTEP</code>: </b>
发起一步增量垃圾收集。
</li>

<li><b><code>LUA_GCSETPAUSE</code>: </b>
把 <code>data</code> 设为 <em>垃圾收集器间歇率</em> 
（参见 <a href="#2.5">&sect;2.5</a>），并返回之前设置的值。
</li>

<li><b><code>LUA_GCSETSTEPMUL</code>: </b>
把 <code>data</code> 设为 <em>垃圾收集器步进倍率</em> 
（参见 <a href="#2.5">&sect;2.5</a>），并返回之前设置的值。
</li>

<li><b><code>LUA_GCISRUNNING</code>: </b>
返回收集器是否在运行（即没有停止）。
</li>

</ul>

<p>
关于这些选项的细节，参见 <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> 。





<hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>
返回给定状态机的内存分配器函数。
如果 <code>ud</code> 不是 <code>NULL</code> ，
Lua 把设置内存分配函数时设置的那个指针置入 <code>*ud</code> 。




<hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>
把 <code>t[k]</code> 的值压栈，
这里的 <code>t</code> 是索引指向的值。
在 Lua 中，这个函数可能触发对应 "index" 事件对应的元方法
（参见 <a href="#2.4">&sect;2.4</a> ）。


<p>
函数将返回压入值的类型。




<hr><h3><a name="lua_getextraspace"><code>lua_getextraspace</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_getextraspace (lua_State *L);</pre>

<p>
返回一个 Lua 状态机中关联的内存块指针。
程序可以把这块内存用于任何用途；而 Lua 不会使用它。


<p>
每一个新线程都会携带一块内存，
初始化为主线程的这块内存的副本。


<p>
默认配置下，这块内存的大小为空指针的大小。
不过你可以重新编译 Lua 设定这块内存不同的大小。
（参见 <code>luaconf.h</code> 中的 <code>LUA_EXTRASPACE</code>。）




<hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getglobal (lua_State *L, const char *name);</pre>

<p>
把全局变量 <name>name</name> 里的值压栈，返回该值的类型。





<hr><h3><a name="lua_geti"><code>lua_geti</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_geti (lua_State *L, int index, lua_Integer i);</pre>

<p>
把 <code>t[i]</code> 的值压栈，
这里的 <code>t</code> 指给定的索引指代的值。
和在 Lua 里一样，这个函数可能会触发 "index" 事件的元方法
（参见 <a href="#2.4">&sect;2.4</a>）。


<p>
返回压入值的类型。





<hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>
如果该索引处的值有元表，则将其元表压栈，返回 1 。
否则不会将任何东西入栈，返回 0 。




<hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>
<pre>int lua_gettable (lua_State *L, int index);</pre>

<p>
把 <code>t[k]</code> 的值压栈，
这里的 <code>t</code> 是指索引指向的值，
而 <code>k</code> 则是栈顶放的值。


<p>
这个函数会弹出堆栈上的键，把结果放在栈上相同位置。
和在 Lua 中一样，
这个函数可能触发对应 "index" 事件的元方法 
（参见 <a href="#2.4">&sect;2.4</a> ）。


<p>
返回压入值的类型。




<hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gettop (lua_State *L);</pre>

<p>
返回栈顶元素的索引。 
因为索引是从 1 开始编号的，
所以这个结果等于栈上的元素个数；
特别指出，0 表示栈为空。



<hr><h3><a name="lua_getuservalue"><code>lua_getuservalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_getuservalue (lua_State *L, int index);</pre>

<p>
将给定索引处的用户数据所关联的 Lua 值压栈。

<p>
返回压入值的类型。




<hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>void lua_insert (lua_State *L, int index);</pre>

<p>
把栈顶元素移动到指定的有效索引处，
依次移动这个索引之上的元素。
不要用伪索引来调用这个函数，
因为伪索引没有真正指向栈上的位置。



<hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ... lua_Integer;</pre>

<p>
Lua 中的整数类型。


<p>
缺省时，这个就是 <code>long long</code>，
（通常是一个 64 位以二为补码的整数），
也可以修改它为 <code>long</code> 或 <code>int</code>
（通常是一个 32 位以二为补码的整数）。
（参见 <code>luaconf.h</code> 中的 <code>LUA_INT</code> 。）

<p>
Lua 定义了两个常量：
<a name="pdf-LUA_MININTEGER"><code>LUA_MININTEGER</code></a> 和
<a name="pdf-LUA_MAXINTEGER"><code>LUA_MAXINTEGER</code></a>
来表示这个类型可以表示的最小和最大值。




<hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>
当给定索引的值是一个布尔量时，返回 1 ，否则返回 0 。



<hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>
当给定索引的值是一个 C 函数时，返回 1 ，否则返回 0 。



<hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>
当给定索引的值是一个函数（ C 或 Lua 函数均可）时，返回 1 ，否则返回 0 。



<hr><h3><a name="lua_isinteger"><code>lua_isinteger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isinteger (lua_State *L, int index);</pre>

<p>
当给定索引的值是一个整数
（其值是一个数字，且内部以整数储存），
时，返回 1 ，否则返回 0 。



<hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>
当给定索引的值是一个轻量用户数据时，返回 1 ，否则返回 0 。




<hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnil (lua_State *L, int index);</pre>

<p>
当给定索引的值是 <b>nil</b> 时，返回 1 ，否则返回 0 。




<hr><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnone (lua_State *L, int index);</pre>

<p>
当给定索引无效时，返回 1 ，否则返回 0 。




<hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnoneornil (lua_State *L, int index);</pre>

<p>
当给定索引无效或其值是 <b>nil</b> 时，
返回 1 ，否则返回 0 。



<hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>
当给定索引的值是一个数字，或是一个可转换为数字的字符串时，返回 1 ，否则返回 0 。




<hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isstring (lua_State *L, int index);</pre>

<p>
当给定索引的值是一个字符串或是一个数字
（数字总能转换成字符串）时，返回 1 ，否则返回 0 。




<hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_istable (lua_State *L, int index);</pre>

<p>
当给定索引的值是一张表时，返回 1 ，否则返回 0 。



<hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isthread (lua_State *L, int index);</pre>

<p>
当给定索引的值是一条线程时，返回 1 ，否则返回 0 。



<hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>
当给定索引的值是一个用户数据（无论是完全的还是轻量的）时，
返回 1 ，否则返回 0 。



<hr><h3><a name="lua_isyieldable"><code>lua_isyieldable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isyieldable (lua_State *L);</pre>

<p>
如果给定的协程可以让出，返回 1 ，否则返回 0 。


<hr><h3><a name="lua_KContext"><code>lua_KContext</code></a></h3>
<pre>typedef ... lua_KContext;</pre>

<p>
延续函数上下文参数的类型。
这一定是一个数字类型。
当有 <code>intptr_t</code> 时，被定义为 <code>intptr_t</code> ，
因此它也可以保存指针。
否则，它被定义为 <code>ptrdiff_t</code>。



<hr><h3><a name="lua_KFunction"><code>lua_KFunction</code></a></h3>
<pre>typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);</pre>

<p>
延续函数的类型（参见 <a href="#4.7">&sect;4.7</a> ）。




<hr><h3><a name="lua_len"><code>lua_len</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_len (lua_State *L, int index);</pre>

<p>
返回给定索引的值的长度。
它等价于 Lua 中的 '<code>#</code>' 操作符
（参见 <a href="#3.4.7">&sect;3.4.7</a>）。
它有可能触发 "length" 事件对应的元方法
（参见 <a href="#2.4">&sect;2.4</a> ）。
结果压栈。




<hr><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname,
              const char *mode);</pre>

<p>
加载一段 Lua 代码块，但不运行它。
如果没有错误，
<code>lua_load</code> 把一个编译好的代码块作为一个 Lua 函数压到栈顶。
否则，压入错误消息。


<p>
<code>lua_load</code> 的返回值可以是：

<ul>

<li><b><a href="#pdf-LUA_OK"><code>LUA_OK</code></a>: </b> 没有错误；</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>: </b>
在预编译时碰到语法错误；</li>

<li><b><a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
内存分配错误；</li>

<li><b><a href="#pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b>
在运行 <code>__gc</code> 元方法时出错了。
（这个错误和代码块加载过程无关，它是由垃圾收集器引发的。）
</li>

</ul>

<p>
<code>lua_load</code> 函数使用一个用户提供的 <code>reader</code>
函数来读取代码块（参见 <a href="#lua_Reader"><code>lua_Reader</code></a> ）。
<code>data</code> 参数会被传入 <code>reader</code> 函数。


<p>
<code>chunkname</code> 这个参数可以赋予代码块一个名字，
这个名字被用于出错信息和调试信息（参见  <a href="#4.9">&sect;4.9</a>）。


<p>
<code>lua_load</code> 会自动检测代码块是文本的还是二进制的，
然后做对应的加载操作（参见程序 <code>luac</code> ）。
字符串 <code>mode</code> 的作用和函数 <a href="#pdf-load"><code>load</code></a> 一致。
它还可以是 <code>NULL</code> 等价于字符串 "<code>bt</code>"。


<p>
<code>lua_load</code> 的内部会使用栈，
因此 reader 函数必须永远在每次返回时保留栈的原样。


<p>
如果返回的函数有上值，
第一个上值会被设置为
保存在注册表（参见 <a href="#4.5">&sect;4.5</a>）
<code>LUA_RIDX_GLOBALS</code> 索引处的全局环境。
在加载主代码块时，这个上值是 <code>_ENV</code> 变量（参见 <a href="#2.2">&sect;2.2</a>）。
其它上值均被初始化为 <b>nil</b>。




<hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>

<p>
创建一个运行在新的独立的状态机中的线程。
如果无法创建线程或状态机（由于内存有限）则返回 <code>NULL</code>。
参数 <code>f</code> 是一个分配器函数； 
Lua 将通过这个函数做状态机内所有的内存分配操作。
第二个参数 <code>ud</code> ，这个指针将在每次调用分配器时被转入。



<hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_newtable (lua_State *L);</pre>

<p>
创建一张空表，并将其压栈。
它等价于 <code>lua_createtable(L, 0, 0)</code> 。




<hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>
创建一条新线程，并将其压栈，
并返回维护这个线程的 <a href="#lua_State"><code>lua_State</code></a> 指针。
这个函数返回的新线程共享原线程的全局环境， 但是它有独立的运行栈。



<p>
没有显式的函数可以用来关闭或销毁掉一个线程。
线程跟其它 Lua 对象一样是垃圾收集的条目之一。




<hr><h3><a name="lua_newuserdata"><code>lua_newuserdata</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void *lua_newuserdata (lua_State *L, size_t size);</pre>

<p>
这个函数分配分配一块指定大小的内存块，
把内存块地址作为一个完全用户数据压栈，
并返回这个地址。

宿主程序可以随意使用这块内存。



<hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>e</em>]</span>
<pre>int lua_next (lua_State *L, int index);</pre>

<p>
从栈顶弹出一个键，
然后把索引指定的表中的一个键值对压栈 （弹出的键之后的 “下一” 对）。
如果表中以无更多元素，
那么 <a href="#lua_next"><code>lua_next</code></a> 将返回 0 （什么也不压栈）。



<p>
典型的遍历方法是这样的：

<pre>
     /*  表放在索引 't' 处 */
     lua_pushnil(L);  /* 第一个键 */
     while (lua_next(L, t) != 0) {
       /* 使用 '键' （在索引 -2 处） 和 '值' （在索引 -1 处）*/
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* 移除 '值' ；保留 '键' 做下一次迭代 */
       lua_pop(L, 1);
     }
</pre>

<p>
在遍历一张表的时候，
不要直接对键调用 <a href="#lua_tolstring"><code>lua_tolstring</code></a> ，
除非你知道这个键一定是一个字符串。
调用 <a href="#lua_tolstring"><code>lua_tolstring</code></a> 有可能改变给定索引位置的值；
这会对下一次调用 <a href="#lua_next"><code>lua_next</code></a> 造成影响。


<p>
关于迭代过程中修改被迭代的表的注意事项参见 <a href="#pdf-next"><code>next</code></a> 函数。



<hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef double lua_Number;</pre>

<p>
Lua 中浮点数的类型。


<p>
Lua 中数字的类型。确省是 double ，但是你改成 float 。
（参见 <code>luaconf.h</code> 中的 <code>LUA_REAL</code> 。）




<hr><h3><a name="lua_numbertointeger"><code>lua_numbertointeger</code></a></h3>
<pre>int lua_numbertointeger (lua_Number n, lua_Integer *p);</pre>

<p>
将一个 Lua 浮点数转换为一个 Lua 整数。
这个宏假设 <code>n</code> 有对应的整数值。
如果该值在 Lua 整数可表示范围内，
就将其转换为一个整数赋给 <code>*p</code>。
宏的结果是一个布尔量，表示转换是否成功。
（注意、由于圆整关系，这个范围测试不用此宏很难做对。）


<p>
该宏有可能对其参数做多次取值。




<hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);</pre>

<p>
以保护模式调用一个函数。


<p>
<code>nargs</code> 和 <code>nresults</code> 的含义与 <a href="#lua_call"><code>lua_call</code></a> 中的相同。
如果在调用过程中没有发生错误，
<a href="#lua_pcall"><code>lua_pcall</code></a> 的行为和 <a href="#lua_call"><code>lua_call</code></a> 完全一致。 
但是，如果有错误发生的话，
<a href="#lua_pcall"><code>lua_pcall</code></a> 会捕获它，
然后把唯一的值（错误消息）压栈，然后返回错误码。 
同 <a href="#lua_call"><code>lua_call</code></a> 一样，
<a href="#lua_pcall"><code>lua_pcall</code></a> 总是把函数本身和它的参数从栈上移除。


<p>
如果 <code>msgh</code> 是 0 ，
返回在栈顶的错误消息就和原始错误消息完全一致。
否则， <code>msgh</code> 就被当成是 <em>错误处理函数</em> 在栈上的索引位置。 
（在当前的实现里，这个索引不能是伪索引。）
在发生运行时错误时，
这个函数会被调用而参数就是错误消息。
错误处理函数的返回值将被 <a href="#lua_pcall"><code>lua_pcall</code></a>
作为错误消息返回在堆栈上。

<p>
典型的用法中，错误处理函数被用来给错误消息加上更多的调试信息，
比如栈跟踪信息。
这些信息在 <a href="#lua_pcall"><code>lua_pcall</code></a> 返回后，
由于栈已经展开，所以收集不到了。

<p>
<a href="#lua_pcall"><code>lua_pcall</code></a> 函数会返回下列常数
（定义在 <code>lua.h</code> 内）中的一个：

<ul>

<li><b><a name="pdf-LUA_OK"><code>LUA_OK</code></a> (0): </b>
成功。</li>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>: </b>
运行时错误。
</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
内存分配错误。对于这种错，Lua 不会调用错误处理函数。
</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>: </b>
在运行错误处理函数时发生的错误。
</li>

<li><b><a name="pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b>
在运行 <code>__gc</code> 元方法时发生的错误。
（这个错误和被调用的函数无关。）
</li>

</ul>




<hr><h3><a name="lua_pcallk"><code>lua_pcallk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int msgh,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
这个函数的行为和 <a href="#lua_pcall"><code>lua_pcall</code></a>
完全一致，只不过它还允许被调用的函数让出
（参见 <a href="#4.7">&sect;4.7</a>）。




<hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, &ndash;]</span>
<pre>void lua_pop (lua_State *L, int n);</pre>

<p>
从栈中弹出 <code>n</code> 个元素。




<hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>
把 <code>b</code> 作为一个布尔量压栈。



<hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>
把一个新的 C 闭包压栈。

<p>
当创建了一个 C 函数后，
你可以给它关联一些值，
这就是在创建一个 C 闭包（参见 <a href="#4.4">&sect;4.4</a>）；
接下来无论函数何时被调用，这些值都可以被这个函数访问到。
为了将一些值关联到一个 C 函数上，
首先这些值需要先被压入堆栈（如果有多个值，第一个先压）。
接下来调用 <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>
来创建出闭包并把这个 C 函数压到栈上。
参数 <code>n</code> 告之函数有多少个值需要关联到函数上。
<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> 也会把这些值从栈上弹出。


<p>
<code>n</code> 的最大值是 255 。


<p>
当 <code>n</code> 为零时，
这个函数将创建出一个 <em>轻量 C 函数</em>，
它就是一个指向 C 函数的指针。
这种情况下，不可能抛出内存错误。



<hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>
将一个 C 函数压栈。 
这个函数接收一个 C 函数指针，
并将一个类型为 <code>function</code> 的 Lua 值压栈。
当这个栈顶的值被调用时，将触发对应的 C 函数。


<p>
注册到 Lua 中的任何函数都必须遵循正确的协议来接收参数和返回值
（参见 <a href="#lua_CFunction"><code>lua_CFunction</code></a> ）。


<p>
<code>lua_pushcfunction</code> 是作为一个宏定义出现的：

<pre>
     #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)
</pre>



<hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>
把一个格式化过的字符串压栈，
然后返回这个字符串的指针。 
它和 C 函数 <code>sprintf</code> 比较像，
不过有一些重要的区别：

<ul>

<li>
你不需要为结果分配空间：
其结果是一个 Lua 字符串，由 Lua 来关心其内存分配 （同时通过垃圾收集来释放内存）。
</li>

<li>
这个转换非常的受限。
不支持符号、宽度、精度。
转换符只支持
'<code>%%</code>' （插入一个字符 '<code>%</code>'），
'<code>%s</code>' （插入一个带零终止符的字符串，没有长度限制）,
'<code>%f</code>' （插入一个 <a href="#lua_Number"><code>lua_Number</code></a>），
'<code>%L</code>' （插入一个 <a href="#lua_Integer"><code>lua_Integer</code></a>），
'<code>%p</code>' （插入一个指针或是一个十六进制数），
'<code>%d</code>' （插入一个 <code>int</code>），
'<code>%c</code>' （插入一个用 <code>int</code> 表示的单字节字符），以及
'<code>%U</code>' （插入一个用 <code>long int</code> 表示的 UTF-8 字）。
</li>

</ul>




<hr><h3><a name="lua_pushglobaltable"><code>lua_pushglobaltable</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushglobaltable (lua_State *L);</pre>

<p>
将全局环境压栈。




<hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>
把值为 <code>n</code> 的整数压栈。





<hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>
把一个轻量用户数据压栈。


<p>
用户数据是保留在 Lua 中的 C 值。
<em>轻量用户数据</em> 表示一个指针 <code>void*</code>。
它是一个像数字一样的值：
你不需要专门创建它，它也没有独立的元表，而且也不会被收集（因为从来不需要创建）。
只要表示的 C 地址相同，两个轻量用户数据就相等。



<hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushliteral (lua_State *L, const char *s);</pre>

<p>
这个宏等价于 <a href="#lua_pushlstring"><code>lua_pushlstring</code></a>，
区别仅在于只能在 <code>s</code> 是一个字面量时才能用它。
它会自动给出字符串的长度。




<hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>
把指针 <code>s</code> 指向的长度为 <code>len</code> 的字符串压栈。
Lua 对这个字符串做一个内部副本（或是复用一个副本），
因此 <code>s</code> 处的内存在函数返回后，可以释放掉或是立刻重用于其它用途。
字符串内可以是任意二进制数据，包括零字符。



<p>
返回内部副本的指针。





<hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnil (lua_State *L);</pre>

<p>
将空值压栈。




<hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>
把一个值为 <code>n</code> 的浮点数压栈。




<hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushstring (lua_State *L, const char *s);</pre>

<p>
将指针 s 指向的零结尾的字符串压栈。
因此 <code>s</code> 处的内存在函数返回后，可以释放掉或是立刻重用于其它用途。


<p>
返回内部副本的指针。


<p>
如果 <code>s</code> 为 <code>NULL</code>，将 <b>nil</b> 压栈并返回 <code>NULL</code>。





<hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_pushthread (lua_State *L);</pre>

<p>
把 <code>L</code> 表示的线程压栈。
如果这个线程是当前状态机的主线程的话，返回 1 。




<hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>
把栈上给定索引处的元素作一个副本压栈。




<hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p>
等价于 <a href="#lua_pushfstring"><code>lua_pushfstring</code></a> ，
不过是用 <code>va_list</code> 接收参数，而不是用可变数量的实际参数。



<hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>
如果索引 <code>index1</code> 与索引 <code>index2</code> 处的值
本身相等（即不调用元方法），返回 1 。
否则返回 0 。
当任何一个索引无效时，也返回 0 。



<hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>int lua_rawget (lua_State *L, int index);</pre>

<p>
类似于 <a href="#lua_gettable"><code>lua_gettable</code></a> ，
但是作一次直接访问（不触发元方法）。



<hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgeti (lua_State *L, int index, lua_Integer n);</pre>

<p>
把 <code>t[n]</code> 的值压栈，
这里的 <code>t</code> 是指给定索引处的表。
这是一次直接访问；就是说，它不会触发元方法。


<p>
返回入栈值的类型。





<hr><h3><a name="lua_rawgetp"><code>lua_rawgetp</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgetp (lua_State *L, int index, const void *p);</pre>

<p>
把 <code>t[k]</code> 的值压栈，
这里的 <code>t</code> 是指给定索引处的表，、
<code>k</code> 是指针 <code>p</code> 对应的轻量用户数据。
这是一次直接访问；就是说，它不会触发元方法。



<p>
返回入栈值的类型。





<hr><h3><a name="lua_rawlen"><code>lua_rawlen</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>size_t lua_rawlen (lua_State *L, int index);</pre>

<p>
返回给定索引处值的固有“长度”：
对于字符串，它指字符串的长度；
对于表；它指不触发元方法的情况下取长度操作（'<code>#</code>'）应得到的值；
对于用户数据，它指为该用户数据分配的内存块的大小；
对于其它值，它为 0 。




<hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_rawset (lua_State *L, int index);</pre>

<p>
类似于 <a href="#lua_settable"><code>lua_settable</code></a> ，
但是是做一次直接赋值（不触发元方法）。





<hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_rawseti (lua_State *L, int index, lua_Integer i);</pre>

<p>
等价于 <code>t[i] = v</code> ，
这里的 <code>t</code> 是指给定索引处的表，
而 <code>v</code> 是栈顶的值。

<p>
这个函数会将值弹出栈。
赋值是直接的；即不会触发元方法。




<hr><h3><a name="lua_rawsetp"><code>lua_rawsetp</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_rawsetp (lua_State *L, int index, const void *p);</pre>

<p>
等价于 <code>t[k] = v</code> ，
这里的 <code>t</code> 是指给定索引处的表，
<code>k</code> 是指针 <code>p</code> 对应的轻量用户数据。
而 <code>v</code> 是栈顶的值。


<p>
这个函数会将值弹出栈。
赋值是直接的；即不会触发元方法。




<hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p>
<a href="#lua_load"><code>lua_load</code></a> 用到的读取器函数，
每次它需要一块新的代码块的时候，
<a href="#lua_load"><code>lua_load</code></a> 就调用读取器，
每次都会传入一个参数 <code>data</code> 。
读取器需要返回含有新的代码块的一块内存的指针，
并把 <code>size</code> 设为这块内存的大小。
内存块必须在下一次函数被调用之前一直存在。
读取器可以通过返回 <code>NULL</code> 或设 <code>size</code> 为 0 来指示代码块结束。
读取器可能返回多个块，每个块可以有任意的大于零的尺寸。




<hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void lua_register (lua_State *L, const char *name, lua_CFunction f);</pre>

<p>
把 C 函数 <code>f</code> 设到全局变量 <code>name</code> 中。
它通过一个宏定义：

<pre>
     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>




<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_remove (lua_State *L, int index);</pre>

<p>
从给定有效索引处移除一个元素，
把这个索引之上的所有元素移下来填补上这个空隙。
不能用伪索引来调用这个函数，因为伪索引并不指向真实的栈上的位置。




<hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_replace (lua_State *L, int index);</pre>

<p>
把栈顶元素放置到给定位置而不移动其它元素
（因此覆盖了那个位置处的值），然后将栈顶元素弹出。



<hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>int lua_resume (lua_State *L, lua_State *from, int nargs);</pre>

<p>
在给定线程中启动或延续一条协程 。


<p>
要启动一个协程的话，
你需要把主函数以及它需要的参数压入线程栈；
然后调用 <a href="#lua_resume"><code>lua_resume</code></a> ，
把 <code>nargs</code> 设为参数的个数。
这次调用会在协程挂起时或是结束运行后返回。
当函数返回时，堆栈中会有传给 href="#lua_yield"><code>lua_yield</code></a> 的所有值，
或是主函数的所有返回值。
当协程让出， <a href="#lua_resume"><code>lua_resume</code></a>
返回 <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> ，
若协程结束运行且没有任何错误时，返回 0 。
如果有错则返回错误代码（参见 <a href="#lua_pcall"><code>lua_pcall</code></a> ）。


<p>
在发生错误的情况下，
堆栈没有展开，
因此你可以使用调试 API 来处理它。
错误消息放在栈顶在。


<p>
要延续一个协程，
你需要清除上次 <a href="#lua_yield"><code>lua_yield</code></a> 遗留下的所有结果，
你把需要传给 <code>yield</code> 作结果的值压栈，
然后调用 <a href="#lua_resume"><code>lua_resume</code></a> 。

<p>
参数 <code>from</code> 表示协程从哪个协程中来延续 <code>L</code> 的。
如果不存在这样一个协程，这个参数可以是 <code>NULL</code> 。





<hr><h3><a name="lua_rotate"><code>lua_rotate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_rotate (lua_State *L, int idx, int n);</pre>

<p>
把从 <code>idx</code> 开始到栈顶的元素轮转 <code>n</code> 个位置。
对于 <code>n</code> 为正数时，轮转方向是向栈顶的；
当 <code>n</code> 为负数时，向栈底方向轮转 <code>-n</code> 个位置。
<code>n</code> 的绝对值不可以比参于轮转的切片长度大。





<hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>
把指定状态机的分配器函数换成带上用户数据 <code>ud</code> 的 <code>f</code> 。




<hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p>
做一个等价于 <code>t[k] = v</code> 的操作，
这里 <code>t</code> 是给出的索引处的值，
而 <code>v</code> 是栈顶的那个值。


<p>
这个函数将把这个值弹出栈。
跟在 Lua 中一样，这个函数可能触发一个 "newindex" 事件的元方法
（参见 <a href="#2.4">&sect;2.4</a>）。




<hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>
从堆栈上弹出一个值，并将其设为全局变量 <code>name</code> 的新值。




<hr><h3><a name="lua_seti"><code>lua_seti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_seti (lua_State *L, int index, lua_Integer n);</pre>

<p>
做一个等价于 <code>t[n] = v</code> 的操作，
这里 <code>t</code> 是给出的索引处的值，
而 <code>v</code> 是栈顶的那个值。


<p>
这个函数将把这个值弹出栈。
跟在 Lua 中一样，这个函数可能触发一个 "newindex" 事件的元方法
（参见 <a href="#2.4">&sect;2.4</a>）。




<hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_setmetatable (lua_State *L, int index);</pre>

<p>
把一张表弹出栈，并将其设为给定索引处的值的元表。




<hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_settable (lua_State *L, int index);</pre>

<p>
做一个等价于 <code>t[k] = v</code> 的操作，
这里 <code>t</code> 是给出的索引处的值，
<code>v</code> 是栈顶的那个值，
<code>k</code> 是栈顶之下的值。

<p>
这个函数会将键和值都弹出栈。
跟在 Lua 中一样，这个函数可能触发一个 "newindex" 事件的元方法
（参见 <a href="#2.4">&sect;2.4</a>）。




<hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_settop (lua_State *L, int index);</pre>

<p>
参数允许传入任何索引以及 0 。
它将把堆栈的栈顶设为这个索引。
如果新的栈顶比原来的大，
超出部分的新元素将被填为 <b>nil</b> 。
如果 <code>index</code> 为 0 ，
把栈上所有元素移除。




<hr><h3><a name="lua_setuservalue"><code>lua_setuservalue</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_setuservalue (lua_State *L, int index);</pre>

<p>
从栈上弹出一个值并将其设为给定索引处用户数据的关联值。




<hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>
一个不透明的结构，
它指向一条线程并间接（通过该线程）引用了整个 Lua 解释器的状态。
Lua 库是完全可重入的：
它没有任何全局变量。
状态机所有的信息都可以通过这个结构访问到。

<p>
这个结构的指针必须作为第一个参数传递给每一个库函数。
<a href="#lua_newstate"><code>lua_newstate</code></a> 是一个例外，
这个函数会从头创建一个 Lua 状态机。



<hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_status (lua_State *L);</pre>

<p>
返回线程 <code>L</code> 的状态。


<p>
正常的线程状态是 0 （<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>）。
当线程用 <a href="#lua_resume"><code>lua_resume</code></a> 执行完毕并抛出了一个错误时，
状态值是错误码。
如果线程被挂起，状态为 <a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a> 。


<p>
你只能在状态为 <a href="#pdf-LUA_OK"><code>LUA_OK</code></a> 的线程中调用函数。
你可以延续一个状态为 <a href="#pdf-LUA_OK"><code>LUA_OK</code></a> 的线程
（用于开始新协程）或是状态为 <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> 的线程
（用于延续协程）。




<hr><h3><a name="lua_stringtonumber"><code>lua_stringtonumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>size_t lua_stringtonumber (lua_State *L, const char *s);</pre>

<p>
将一个零结尾的字符串 <code>s</code> 转换为一个数字，
将这个数字压栈，并返回字符串的总长度（即长度加一）。
转换的结果可能是整数也可能是浮点数，
这取决于 Lua 的转换语法（参见 <a href="#3.1">&sect;3.1</a>）。
这个字符串可以有前置和后置的空格以及符号。
如果字符串并非一个有效的数字，返回 0 并不把任何东西压栈。
（注意，这个结果可以当成一个布尔量使用，为真即转换成功。）




<hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>
把给定索引处的 Lua 值转换为一个 C 中的布尔量（ 0 或是 1 ）。
和 Lua 中做的所有测试一样， 
<a href="#lua_toboolean"><code>lua_toboolean</code></a> 
会把任何不同于 <b>false</b> 和 <b>nil</b> 的值当作真返回；
否则就返回假。
（如果你想只接收真正的 boolean 值，
就需要使用 <a href="#lua_isboolean"><code>lua_isboolean</code></a> 来测试值的类型。）




<hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>
把给定索引处的 Lua 值转换为一个 C 函数。
这个值必须是一个 C 函数；
如果不是就返回 <code>NULL</code> 。





<hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p>
等价于调用 <a href="#lua_tointegerx"><code>lua_tointegerx</code></a>，
其参数 <code>isnum</code> 为 <code>NULL</code>。



<hr><h3><a name="lua_tointegerx"><code>lua_tointegerx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);</pre>

<p>
将给定索引处的 Lua 值转换为带符号的整数类型
<a href="#lua_Integer"><code>lua_Integer</code></a>。
这个 Lua 值必须是一个整数，或是一个可以被转换为整数
（参见 <a href="#3.4.3">&sect;3.4.3</a>）的数字或字符串；
否则，<code>lua_tointegerx</code> 返回 0 。


<p>
如果 <code>isnum</code> 不是 <code>NULL</code>，
<code>*isnum</code> 会被设为操作是否成功。




<hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>
把给定索引处的 Lua 值转换为一个 C 字符串。
如果 <code>len</code> 不为 <code>NULL</code> ，
它还把字符串长度设到 <code>*len</code> 中。
这个 Lua 值必须是一个字符串或是一个数字； 
否则返回返回 <code>NULL</code> 。
如果值是一个数字， <code>lua_tolstring</code>
还会 <em>把堆栈中的那个值的实际类型转换为一个字符串</em>。
（当遍历一张表的时候，
若把 <code>lua_tolstring</code> 作用在键上，
这个转换有可能导致 <a href="#lua_next"><code>lua_next</code></a> 弄错。）


<p>
<code>lua_tolstring</code> 返回一个已对齐指针
指向 Lua 状态机中的字符串。
这个字符串总能保证 （ C 要求的）最后一个字符为零 ('\0') ，
而且它允许在字符串内包含多个这样的零。 


<p>
因为 Lua 中可能发生垃圾收集，
所以不保证 <code>lua_tolstring</code> 返回的指针，
在对应的值从堆栈中移除后依然有效。



<hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p>
等价于调用 <a href="#lua_tonumberx"><code>lua_tonumberx</code></a>，
其参数 <code>isnum</code> 为 <code>NULL</code>。





<hr><h3><a name="lua_tonumberx"><code>lua_tonumberx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);</pre>

<p>
把给定索引处的 Lua 值转换为 <a href="#lua_Number"><code>lua_Number</code></a> 这样一个 C 类型
（参见 lua_Number ）。
这个 Lua 值必须是一个数字或是一个可转换为数字的字符串 
（参见 <a href="#3.4.3">&sect;3.4.3</a>）；
否则， <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> 返回 0 。


<p>
如果 <code>isnum</code> 不是 <code>NULL</code>，
<code>*isnum</code> 会被设为操作是否成功。




<hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>
把给定索引处的值转换为一般的 C 指针 (<code>void*</code>) 。
这个值可以是一个用户对象，表 ，线程或是一个函数；
否则， <code>lua_topointer</code> 返回 <code>NULL</code> 。
不同的对象有不同的指针。
不存在把指针再转回原有类型的方法。


<p>
这个函数通常只用于调试信息。




<hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p>
等价于调用 <a href="#lua_tolstring"><code>lua_tolstring</code></a> ，
其参数 <code>len</code> 为 <code>NULL</code> 。




<hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>
把给定索引处的值转换为一个 Lua 线程
（表示为 <code>lua_State*</code>）。
这个值必须是一个线程；
否则函数返回 <code>NULL</code>。




<hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>
如果给定索引处的值是一个完全用户数据，
函数返回其内存块的地址。
如果值是一个轻量用户数据，
那么就返回它表示的指针。
否则，返回 <code>NULL</code> 。




<hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_type (lua_State *L, int index);</pre>

<p>
返回给定有效索引处值的类型，
当索引无效（或无法访问）时则返回 <code>LUA_TNONE</code>。
<a href="#lua_type"><code>lua_type</code></a> 返回的类型被编码为一些个在
<code>lua.h</code> 中定义的常量：
<a name="pdf-LUA_TNIL"><code>LUA_TNIL</code></a>，
<a name="pdf-LUA_TNUMBER"><code>LUA_TNUMBER</code></a>，
<a name="pdf-LUA_TBOOLEAN"><code>LUA_TBOOLEAN</code></a>，
<a name="pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>，
<a name="pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>，
<a name="pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>，
<a name="pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>，
<a name="pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>，
<a name="pdf-LUA_TLIGHTUSERDATA"><code>LUA_TLIGHTUSERDATA</code></a>。





<hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *lua_typename (lua_State *L, int tp);</pre>

<p>
返回 <code>tp</code> 表示的类型名，
这个 <code>tp</code> 必须是 <a href="#lua_type"><code>lua_type</code></a>
可能返回的值中之一。




<hr><h3><a name="lua_Unsigned"><code>lua_Unsigned</code></a></h3>
<pre>typedef ... lua_Unsigned;</pre>

<p>
<a href="#lua_Integer"><code>lua_Integer</code></a> 的无符号版本。





<hr><h3><a name="lua_upvalueindex"><code>lua_upvalueindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_upvalueindex (int i);</pre>

<p>
返回当前运行的函数（参见 <a href="#4.4">&sect;4.4</a>）的第 <code>i</code> 个上值的伪索引。




<hr><h3><a name="lua_version"><code>lua_version</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const lua_Number *lua_version (lua_State *L);</pre>

<p>
返回保存在 Lua 内核中储存的版本数字的地址。
当调用时传入一个合法的 <a href="#lua_State"><code>lua_State</code></a> ，
返回创建该状态机时的版本地址。
如果用 <code>NULL</code> 调用，
返回调用者的版本地址。




<hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p>
被 <a href="#lua_dump"><code>lua_dump</code></a> 用到的写入器函数。
每次 <a href="#lua_dump"><code>lua_dump</code></a> 产生了一段新的代码块，
它都会调用写入器。
传入要写入的缓冲区 (<code>p</code>) 和它的尺寸 (<code>sz</code>) ，
以及传给 <a href="#lua_dump"><code>lua_dump</code></a> 的参数 <code>data</code> 。



<p>
写入器会返回一个错误码：
0 表示没有错误； 别的值均表示一个错误，
并且会让 <a href="#lua_dump"><code>lua_dump</code></a> 停止再次调用写入器。




<hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>
交换同一个状态机下不同线程中的值。


<p>
这个函数会从 <code>from</code> 的栈上弹出 <code>n</code> 个值，
然后把它们压入 <code>to</code> 的栈上。





<hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>int lua_yield (lua_State *L, int nresults);</pre>

<p>
这个函数等价于调用 <a href="#lua_yieldk"><code>lua_yieldk</code></a>，
不同的是不提供延续函数（参见 <a href="#4.7">&sect;4.7</a>）。
因此，当线程被延续，线程会继续运行调用 <code>lua_yield</code> 函数的函数。




<hr><h3><a name="lua_yieldk"><code>lua_yieldk</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>int lua_yieldk (lua_State *L,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
让出协程（线程）。


<p>
当 C 函数调用了 <a href="#lua_yieldk"><code>lua_yieldk</code></a>，
当前运行的协程会挂起，
启动这个线程的 <a href="#lua_resume"><code>lua_resume</code></a> 调用返回。
参数 <code>nresults</code> 指栈上需返回给
<a href="#lua_resume"><code>lua_resume</code></a> 的返回值的个数。


<p>
当协程再次被延续时，
Lua 调用延续函数 <code>k</code> 继续运行被挂起（参见 <a href="#4.7">&sect;4.7</a>）的 C 函数。
延续函数会从前一个函数中接收到相同的栈，
栈中的 <code>n</code> 个返回值被移除而压入了从
<a href="#lua_resume"><code>lua_resume</code></a> 传入的参数。
此外，延续函数还会收到传给 <a href="#lua_yieldk"><code>lua_yieldk</code></a>
的参数 <code>ctx</code>。


<p>
通常，这个函数不会返回；
当协程一次次延续，将从延续函数继续运行。
然而，有一个例外：
当这个函数从一个逐行运行的钩子函数（参见 <a href="#4.9">&sect;4.9</a>）
中调用时，<code>lua_yieldk</code> 不可以提供延续函数。
（也就是类似 <a href="#lua_yield"><code>lua_yield</code></a> 的形式），
而此时，钩子函数在调用完让出后将立刻返回。
Lua 会使协程让出，一旦协程再次被延续，
触发钩子的函数会继续正常运行。


<p>
当一个线程处于未提供延续函数的 C 调用中，调用它会抛出一个错误。
从并非用延续方式（例如：主线程）启动的线程中调用它也会这样。





<h2>4.9 &ndash; <a name="4.9">The Debug Interface</a></h2>

<p>
Lua has no built-in debugging facilities.
Instead, it offers a special interface
by means of functions and <em>hooks</em>.
This interface allows the construction of different
kinds of debuggers, profilers, and other tools
that need "inside information" from the interpreter.



<hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) number of upvalues */
  unsigned char nparams;      /* (u) number of parameters */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  <em>other fields</em>
} lua_Debug;</pre>

<p>
A structure used to carry different pieces of
information about a function or an activation record.
<a href="#lua_getstack"><code>lua_getstack</code></a> fills only the private part
of this structure, for later use.
To fill the other fields of <a href="#lua_Debug"><code>lua_Debug</code></a> with useful information,
call <a href="#lua_getinfo"><code>lua_getinfo</code></a>.


<p>
The fields of <a href="#lua_Debug"><code>lua_Debug</code></a> have the following meaning:

<ul>

<li><b><code>source</code>: </b>
the name of the chunk that created the function.
If <code>source</code> starts with a '<code>@</code>',
it means that the function was defined in a file where
the file name follows the '<code>@</code>'.
If <code>source</code> starts with a '<code>=</code>',
the remainder of its contents describe the source in a user-dependent manner.
Otherwise,
the function was defined in a string where
<code>source</code> is that string.
</li>

<li><b><code>short_src</code>: </b>
a "printable" version of <code>source</code>, to be used in error messages.
</li>

<li><b><code>linedefined</code>: </b>
the line number where the definition of the function starts.
</li>

<li><b><code>lastlinedefined</code>: </b>
the line number where the definition of the function ends.
</li>

<li><b><code>what</code>: </b>
the string <code>"Lua"</code> if the function is a Lua function,
<code>"C"</code> if it is a C&nbsp;function,
<code>"main"</code> if it is the main part of a chunk.
</li>

<li><b><code>currentline</code>: </b>
the current line where the given function is executing.
When no line information is available,
<code>currentline</code> is set to -1.
</li>

<li><b><code>name</code>: </b>
a reasonable name for the given function.
Because functions in Lua are first-class values,
they do not have a fixed name:
some functions can be the value of multiple global variables,
while others can be stored only in a table field.
The <code>lua_getinfo</code> function checks how the function was
called to find a suitable name.
If it cannot find a name,
then <code>name</code> is set to <code>NULL</code>.
</li>

<li><b><code>namewhat</code>: </b>
explains the <code>name</code> field.
The value of <code>namewhat</code> can be
<code>"global"</code>, <code>"local"</code>, <code>"method"</code>,
<code>"field"</code>, <code>"upvalue"</code>, or <code>""</code> (the empty string),
according to how the function was called.
(Lua uses the empty string when no other option seems to apply.)
</li>

<li><b><code>istailcall</code>: </b>
true if this function invocation was called by a tail call.
In this case, the caller of this level is not in the stack.
</li>

<li><b><code>nups</code>: </b>
the number of upvalues of the function.
</li>

<li><b><code>nparams</code>: </b>
the number of fixed parameters of the function
(always 0&nbsp;for C&nbsp;functions).
</li>

<li><b><code>isvararg</code>: </b>
true if the function is a vararg function
(always true for C&nbsp;functions).
</li>

</ul>




<hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>
Returns the current hook function.





<hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookcount (lua_State *L);</pre>

<p>
Returns the current hook count.





<hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookmask (lua_State *L);</pre>

<p>
Returns the current hook mask.





<hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>e</em>]</span>
<pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>
Gets information about a specific function or function invocation.


<p>
To get information about a function invocation,
the parameter <code>ar</code> must be a valid activation record that was
filled by a previous call to <a href="#lua_getstack"><code>lua_getstack</code></a> or
given as argument to a hook (see <a href="#lua_Hook"><code>lua_Hook</code></a>).


<p>
To get information about a function you push it onto the stack
and start the <code>what</code> string with the character '<code>&gt;</code>'.
(In that case,
<code>lua_getinfo</code> pops the function from the top of the stack.)
For instance, to know in which line a function <code>f</code> was defined,
you can write the following code:

<pre>
     lua_Debug ar;
     lua_getglobal(L, "f");  /* get global 'f' */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>
Each character in the string <code>what</code>
selects some fields of the structure <code>ar</code> to be filled or
a value to be pushed on the stack:

<ul>

<li><b>'<code>n</code>': </b> fills in the field <code>name</code> and <code>namewhat</code>;
</li>

<li><b>'<code>S</code>': </b>
fills in the fields <code>source</code>, <code>short_src</code>,
<code>linedefined</code>, <code>lastlinedefined</code>, and <code>what</code>;
</li>

<li><b>'<code>l</code>': </b> fills in the field <code>currentline</code>;
</li>

<li><b>'<code>t</code>': </b> fills in the field <code>istailcall</code>;
</li>

<li><b>'<code>u</code>': </b> fills in the fields
<code>nups</code>, <code>nparams</code>, and <code>isvararg</code>;
</li>

<li><b>'<code>f</code>': </b>
pushes onto the stack the function that is
running at the given level;
</li>

<li><b>'<code>L</code>': </b>
pushes onto the stack a table whose indices are the
numbers of the lines that are valid on the function.
(A <em>valid line</em> is a line with some associated code,
that is, a line where you can put a break point.
Non-valid lines include empty lines and comments.)


<p>
If this option is given together with option '<code>f</code>',
its table is pushed after the function.
</li>

</ul>

<p>
This function returns 0 on error
(for instance, an invalid option in <code>what</code>).





<hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
Gets information about a local variable of
a given activation record or a given function.


<p>
In the first case,
the parameter <code>ar</code> must be a valid activation record that was
filled by a previous call to <a href="#lua_getstack"><code>lua_getstack</code></a> or
given as argument to a hook (see <a href="#lua_Hook"><code>lua_Hook</code></a>).
The index <code>n</code> selects which local variable to inspect;
see <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a> for details about variable indices
and names.


<p>
<a href="#lua_getlocal"><code>lua_getlocal</code></a> pushes the variable's value onto the stack
and returns its name.


<p>
In the second case, <code>ar</code> must be <code>NULL</code> and the function
to be inspected must be at the top of the stack.
In this case, only parameters of Lua functions are visible
(as there is no information about what variables are active)
and no values are pushed onto the stack.


<p>
Returns <code>NULL</code> (and pushes nothing)
when the index is greater than
the number of active local variables.





<hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>
Gets information about the interpreter runtime stack.


<p>
This function fills parts of a <a href="#lua_Debug"><code>lua_Debug</code></a> structure with
an identification of the <em>activation record</em>
of the function executing at a given level.
Level&nbsp;0 is the current running function,
whereas level <em>n+1</em> is the function that has called level <em>n</em>
(except for tail calls, which do not count on the stack).
When there are no errors, <a href="#lua_getstack"><code>lua_getstack</code></a> returns 1;
when called with a level greater than the stack depth,
it returns 0.





<hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
Gets information about a closure's upvalue.
(For Lua functions,
upvalues are the external local variables that the function uses,
and that are consequently included in its closure.)
<a href="#lua_getupvalue"><code>lua_getupvalue</code></a> gets the index <code>n</code> of an upvalue,
pushes the upvalue's value onto the stack,
and returns its name.
<code>funcindex</code> points to the closure in the stack.
(Upvalues have no particular order,
as they are active through the whole function.
So, they are numbered in an arbitrary order.)


<p>
Returns <code>NULL</code> (and pushes nothing)
when the index is greater than the number of upvalues.
For C&nbsp;functions, this function uses the empty string <code>""</code>
as a name for all upvalues.





<hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>
Type for debugging hook functions.


<p>
Whenever a hook is called, its <code>ar</code> argument has its field
<code>event</code> set to the specific event that triggered the hook.
Lua identifies these events with the following constants:
<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>, <a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>,
<a name="pdf-LUA_HOOKTAILCALL"><code>LUA_HOOKTAILCALL</code></a>, <a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>,
and <a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>.
Moreover, for line events, the field <code>currentline</code> is also set.
To get the value of any other field in <code>ar</code>,
the hook must call <a href="#lua_getinfo"><code>lua_getinfo</code></a>.


<p>
For call events, <code>event</code> can be <code>LUA_HOOKCALL</code>,
the normal value, or <code>LUA_HOOKTAILCALL</code>, for a tail call;
in this case, there will be no corresponding return event.


<p>
While Lua is running a hook, it disables other calls to hooks.
Therefore, if a hook calls back Lua to execute a function or a chunk,
this execution occurs without any calls to hooks.


<p>
Hook functions cannot have continuations,
that is, they cannot call <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
<a href="#lua_pcallk"><code>lua_pcallk</code></a>, or <a href="#lua_callk"><code>lua_callk</code></a> with a non-null <code>k</code>.


<p>
Hook functions can yield under the following conditions:
Only count and line events can yield
and they cannot yield any value;
to yield a hook function must finish its execution
calling <a href="#lua_yield"><code>lua_yield</code></a> with <code>nresults</code> equal to zero.





<hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>
Sets the debugging hook function.


<p>
Argument <code>f</code> is the hook function.
<code>mask</code> specifies on which events the hook will be called:
it is formed by a bitwise or of the constants
<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>,
<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>,
<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>,
and <a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>.
The <code>count</code> argument is only meaningful when the mask
includes <code>LUA_MASKCOUNT</code>.
For each event, the hook is called as explained below:

<ul>

<li><b>The call hook: </b> is called when the interpreter calls a function.
The hook is called just after Lua enters the new function,
before the function gets its arguments.
</li>

<li><b>The return hook: </b> is called when the interpreter returns from a function.
The hook is called just before Lua leaves the function.
There is no standard way to access the values
to be returned by the function.
</li>

<li><b>The line hook: </b> is called when the interpreter is about to
start the execution of a new line of code,
or when it jumps back in the code (even to the same line).
(This event only happens while Lua is executing a Lua function.)
</li>

<li><b>The count hook: </b> is called after the interpreter executes every
<code>count</code> instructions.
(This event only happens while Lua is executing a Lua function.)
</li>

</ul>

<p>
A hook is disabled by setting <code>mask</code> to zero.





<hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
Sets the value of a local variable of a given activation record.
Parameters <code>ar</code> and <code>n</code> are as in <a href="#lua_getlocal"><code>lua_getlocal</code></a>
(see <a href="#lua_getlocal"><code>lua_getlocal</code></a>).
<a href="#lua_setlocal"><code>lua_setlocal</code></a> assigns the value at the top of the stack
to the variable and returns its name.
It also pops the value from the stack.


<p>
Returns <code>NULL</code> (and pops nothing)
when the index is greater than
the number of active local variables.





<hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
Sets the value of a closure's upvalue.
It assigns the value at the top of the stack
to the upvalue and returns its name.
It also pops the value from the stack.
Parameters <code>funcindex</code> and <code>n</code> are as in the <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>
(see <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>).


<p>
Returns <code>NULL</code> (and pops nothing)
when the index is greater than the number of upvalues.





<hr><h3><a name="lua_upvalueid"><code>lua_upvalueid</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_upvalueid (lua_State *L, int funcindex, int n);</pre>

<p>
Returns a unique identifier for the upvalue numbered <code>n</code>
from the closure at index <code>funcindex</code>.
Parameters <code>funcindex</code> and <code>n</code> are as in the <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>
(see <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>)
(but <code>n</code> cannot be greater than the number of upvalues).


<p>
These unique identifiers allow a program to check whether different
closures share upvalues.
Lua closures that share an upvalue
(that is, that access a same external local variable)
will return identical ids for those upvalue indices.





<hr><h3><a name="lua_upvaluejoin"><code>lua_upvaluejoin</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_upvaluejoin (lua_State *L, int funcindex1, int n1,
                                    int funcindex2, int n2);</pre>

<p>
Make the <code>n1</code>-th upvalue of the Lua closure at index <code>funcindex1</code>
refer to the <code>n2</code>-th upvalue of the Lua closure at index <code>funcindex2</code>.







<h1>5 &ndash; <a name="5">The Auxiliary Library</a></h1>

<p>

The <em>auxiliary library</em> provides several convenient functions
to interface C with Lua.
While the basic API provides the primitive functions for all
interactions between C and Lua,
the auxiliary library provides higher-level functions for some
common tasks.


<p>
All functions and types from the auxiliary library
are defined in header file <code>lauxlib.h</code> and
have a prefix <code>luaL_</code>.


<p>
All functions in the auxiliary library are built on
top of the basic API,
and so they provide nothing that cannot be done with that API.
Nevertheless, the use of the auxiliary library ensures
more consistency to your code.


<p>
Several functions in the auxiliary library use internally some
extra stack slots.
When a function in the auxiliary library uses less than five slots,
it does not check the stack size;
it simply assumes that there are enough slots.


<p>
Several functions in the auxiliary library are used to
check C&nbsp;function arguments.
Because the error message is formatted for arguments
(e.g., "<code>bad argument #1</code>"),
you should not use these functions for other stack values.


<p>
Functions called <code>luaL_check*</code>
always raise an error if the check is not satisfied.



<h2>5.1 &ndash; <a name="5.1">Functions and Types</a></h2>

<p>
Here we list all functions and types from the auxiliary library
in alphabetical order.



<hr><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addchar (luaL_Buffer *B, char c);</pre>

<p>
Adds the byte <code>c</code> to the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).





<hr><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre>

<p>
Adds the string pointed to by <code>s</code> with length <code>l</code> to
the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
The string can contain embedded zeros.





<hr><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addsize (luaL_Buffer *B, size_t n);</pre>

<p>
Adds to the buffer <code>B</code> (see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>)
a string of length <code>n</code> previously copied to the
buffer area (see <a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a>).





<hr><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addstring (luaL_Buffer *B, const char *s);</pre>

<p>
Adds the zero-terminated string pointed to by <code>s</code>
to the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).





<hr><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3><p>
<span class="apii">[-1, +?, <em>e</em>]</span>
<pre>void luaL_addvalue (luaL_Buffer *B);</pre>

<p>
Adds the value at the top of the stack
to the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
Pops the value.


<p>
This is the only function on string buffers that can (and must)
be called with an extra element on the stack,
which is the value to be added to the buffer.





<hr><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_argcheck (lua_State *L,
                    int cond,
                    int arg,
                    const char *extramsg);</pre>

<p>
Checks whether <code>cond</code> is true.
If it is not, raises an error with a standard message (see <a href="#luaL_argerror"><code>luaL_argerror</code></a>).





<hr><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_argerror (lua_State *L, int arg, const char *extramsg);</pre>

<p>
Raises an error reporting a problem with argument <code>arg</code>
of the C function that called it,
using a standard message
that includes <code>extramsg</code> as a comment:

<pre>
     bad argument #<em>arg</em> to '<em>funcname</em>' (<em>extramsg</em>)
</pre><p>
This function never returns.





<hr><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3>
<pre>typedef struct luaL_Buffer luaL_Buffer;</pre>

<p>
Type for a <em>string buffer</em>.


<p>
A string buffer allows C&nbsp;code to build Lua strings piecemeal.
Its pattern of use is as follows:

<ul>

<li>First declare a variable <code>b</code> of type <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>.</li>

<li>Then initialize it with a call <code>luaL_buffinit(L, &amp;b)</code>.</li>

<li>
Then add string pieces to the buffer calling any of
the <code>luaL_add*</code> functions.
</li>

<li>
Finish by calling <code>luaL_pushresult(&amp;b)</code>.
This call leaves the final string on the top of the stack.
</li>

</ul>

<p>
If you know beforehand the total size of the resulting string,
you can use the buffer like this:

<ul>

<li>First declare a variable <code>b</code> of type <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>.</li>

<li>Then initialize it and preallocate a space of
size <code>sz</code> with a call <code>luaL_buffinitsize(L, &amp;b, sz)</code>.</li>

<li>Then copy the string into that space.</li>

<li>
Finish by calling <code>luaL_pushresultsize(&amp;b, sz)</code>,
where <code>sz</code> is the total size of the resulting string
copied into that space.
</li>

</ul>

<p>
During its normal operation,
a string buffer uses a variable number of stack slots.
So, while using a buffer, you cannot assume that you know where
the top of the stack is.
You can use the stack between successive calls to buffer operations
as long as that use is balanced;
that is,
when you call a buffer operation,
the stack is at the same level
it was immediately after the previous buffer operation.
(The only exception to this rule is <a href="#luaL_addvalue"><code>luaL_addvalue</code></a>.)
After calling <a href="#luaL_pushresult"><code>luaL_pushresult</code></a> the stack is back to its
level when the buffer was initialized,
plus the final string on its top.





<hr><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre>

<p>
Initializes a buffer <code>B</code>.
This function does not allocate any space;
the buffer must be declared as a variable
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).





<hr><h3><a name="luaL_buffinitsize"><code>luaL_buffinitsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz);</pre>

<p>
Equivalent to the sequence
<a href="#luaL_buffinit"><code>luaL_buffinit</code></a>, <a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>.





<hr><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
<pre>int luaL_callmeta (lua_State *L, int obj, const char *e);</pre>

<p>
Calls a metamethod.


<p>
If the object at index <code>obj</code> has a metatable and this
metatable has a field <code>e</code>,
this function calls this field passing the object as its only argument.
In this case this function returns true and pushes onto the
stack the value returned by the call.
If there is no metatable or no metamethod,
this function returns false (without pushing any value on the stack).





<hr><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkany (lua_State *L, int arg);</pre>

<p>
Checks whether the function has an argument
of any type (including <b>nil</b>) at position <code>arg</code>.





<hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_checkinteger (lua_State *L, int arg);</pre>

<p>
Checks whether the function argument <code>arg</code> is an integer
(or can be converted to an integer)
and returns this integer cast to a <a href="#lua_Integer"><code>lua_Integer</code></a>.





<hr><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checklstring (lua_State *L, int arg, size_t *l);</pre>

<p>
Checks whether the function argument <code>arg</code> is a string
and returns this string;
if <code>l</code> is not <code>NULL</code> fills <code>*l</code>
with the string's length.


<p>
This function uses <a href="#lua_tolstring"><code>lua_tolstring</code></a> to get its result,
so all conversions and caveats of that function apply here.





<hr><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_checknumber (lua_State *L, int arg);</pre>

<p>
Checks whether the function argument <code>arg</code> is a number
and returns this number.





<hr><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_checkoption (lua_State *L,
                      int arg,
                      const char *def,
                      const char *const lst[]);</pre>

<p>
Checks whether the function argument <code>arg</code> is a string and
searches for this string in the array <code>lst</code>
(which must be NULL-terminated).
Returns the index in the array where the string was found.
Raises an error if the argument is not a string or
if the string cannot be found.


<p>
If <code>def</code> is not <code>NULL</code>,
the function uses <code>def</code> as a default value when
there is no argument <code>arg</code> or when this argument is <b>nil</b>.


<p>
This is a useful function for mapping strings to C&nbsp;enums.
(The usual convention in Lua libraries is
to use strings instead of numbers to select options.)





<hr><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre>

<p>
Grows the stack size to <code>top + sz</code> elements,
raising an error if the stack cannot grow to that size.
<code>msg</code> is an additional text to go into the error message
(or <code>NULL</code> for no additional text).





<hr><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checkstring (lua_State *L, int arg);</pre>

<p>
Checks whether the function argument <code>arg</code> is a string
and returns this string.


<p>
This function uses <a href="#lua_tolstring"><code>lua_tolstring</code></a> to get its result,
so all conversions and caveats of that function apply here.





<hr><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checktype (lua_State *L, int arg, int t);</pre>

<p>
Checks whether the function argument <code>arg</code> has type <code>t</code>.
See <a href="#lua_type"><code>lua_type</code></a> for the encoding of types for <code>t</code>.





<hr><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void *luaL_checkudata (lua_State *L, int arg, const char *tname);</pre>

<p>
Checks whether the function argument <code>arg</code> is a userdata
of the type <code>tname</code> (see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>) and
returns the userdata address (see <a href="#lua_touserdata"><code>lua_touserdata</code></a>).





<hr><h3><a name="luaL_checkversion"><code>luaL_checkversion</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_checkversion (lua_State *L);</pre>

<p>
Checks whether the core running the call,
the core that created the Lua state,
and the code making the call are all using the same version of Lua.
Also checks whether the core running the call
and the core that created the Lua state
are using the same address space.





<hr><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3><p>
<span class="apii">[-0, +?, <em>e</em>]</span>
<pre>int luaL_dofile (lua_State *L, const char *filename);</pre>

<p>
Loads and runs the given file.
It is defined as the following macro:

<pre>
     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
It returns false if there are no errors
or true in case of errors.





<hr><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3><p>
<span class="apii">[-0, +?, &ndash;]</span>
<pre>int luaL_dostring (lua_State *L, const char *str);</pre>

<p>
Loads and runs the given string.
It is defined as the following macro:

<pre>
     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
It returns false if there are no errors
or true in case of errors.





<hr><h3><a name="luaL_error"><code>luaL_error</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_error (lua_State *L, const char *fmt, ...);</pre>

<p>
Raises an error.
The error message format is given by <code>fmt</code>
plus any extra arguments,
following the same rules of <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>.
It also adds at the beginning of the message the file name and
the line number where the error occurred,
if this information is available.


<p>
This function never returns,
but it is an idiom to use it in C&nbsp;functions
as <code>return luaL_error(<em>args</em>)</code>.





<hr><h3><a name="luaL_execresult"><code>luaL_execresult</code></a></h3><p>
<span class="apii">[-0, +3, <em>e</em>]</span>
<pre>int luaL_execresult (lua_State *L, int stat);</pre>

<p>
This function produces the return values for
process-related functions in the standard library
(<a href="#pdf-os.execute"><code>os.execute</code></a> and <a href="#pdf-io.close"><code>io.close</code></a>).





<hr><h3><a name="luaL_fileresult"><code>luaL_fileresult</code></a></h3><p>
<span class="apii">[-0, +(1|3), <em>e</em>]</span>
<pre>int luaL_fileresult (lua_State *L, int stat, const char *fname);</pre>

<p>
This function produces the return values for
file-related functions in the standard library
(<a href="#pdf-io.open"><code>io.open</code></a>, <a href="#pdf-os.rename"><code>os.rename</code></a>, <a href="#pdf-file:seek"><code>file:seek</code></a>, etc.).





<hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
<pre>int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre>

<p>
Pushes onto the stack the field <code>e</code> from the metatable
of the object at index <code>obj</code> and returns the type of pushed value.
If the object does not have a metatable,
or if the metatable does not have this field,
pushes nothing and returns <code>LUA_TNIL</code>.





<hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_getmetatable (lua_State *L, const char *tname);</pre>

<p>
Pushes onto the stack the metatable associated with name <code>tname</code>
in the registry (see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).
If there is no metatable associated with <code>tname</code>,
returns false and pushes <b>nil</b>.





<hr><h3><a name="luaL_getsubtable"><code>luaL_getsubtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_getsubtable (lua_State *L, int idx, const char *fname);</pre>

<p>
Ensures that the value <code>t[fname]</code>,
where <code>t</code> is the value at index <code>idx</code>,
is a table,
and pushes that table onto the stack.
Returns true if it finds a previous table there
and false if it creates a new table.





<hr><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre>

<p>
Creates a copy of string <code>s</code> by replacing
any occurrence of the string <code>p</code>
with the string <code>r</code>.
Pushes the resulting string on the stack and returns it.





<hr><h3><a name="luaL_len"><code>luaL_len</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>lua_Integer luaL_len (lua_State *L, int index);</pre>

<p>
Returns the "length" of the value at the given index
as a number;
it is equivalent to the '<code>#</code>' operator in Lua (see <a href="#3.4.7">&sect;3.4.7</a>).
Raises an error if the result of the operation is not an integer.
(This case only can happen through metamethods.)





<hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>

<p>
Equivalent to <a href="#luaL_loadbufferx"><code>luaL_loadbufferx</code></a> with <code>mode</code> equal to <code>NULL</code>.





<hr><h3><a name="luaL_loadbufferx"><code>luaL_loadbufferx</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadbufferx (lua_State *L,
                      const char *buff,
                      size_t sz,
                      const char *name,
                      const char *mode);</pre>

<p>
Loads a buffer as a Lua chunk.
This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in the
buffer pointed to by <code>buff</code> with size <code>sz</code>.


<p>
This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>.
<code>name</code> is the chunk name,
used for debug information and error messages.
The string <code>mode</code> works as in function <a href="#lua_load"><code>lua_load</code></a>.





<hr><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_loadfile (lua_State *L, const char *filename);</pre>

<p>
Equivalent to <a href="#luaL_loadfilex"><code>luaL_loadfilex</code></a> with <code>mode</code> equal to <code>NULL</code>.





<hr><h3><a name="luaL_loadfilex"><code>luaL_loadfilex</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_loadfilex (lua_State *L, const char *filename,
                                            const char *mode);</pre>

<p>
Loads a file as a Lua chunk.
This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in the file
named <code>filename</code>.
If <code>filename</code> is <code>NULL</code>,
then it loads from the standard input.
The first line in the file is ignored if it starts with a <code>#</code>.


<p>
The string <code>mode</code> works as in function <a href="#lua_load"><code>lua_load</code></a>.


<p>
This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>,
but it has an extra error code <a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a>
if it cannot open/read the file or the file has a wrong mode.


<p>
As <a href="#lua_load"><code>lua_load</code></a>, this function only loads the chunk;
it does not run it.





<hr><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadstring (lua_State *L, const char *s);</pre>

<p>
Loads a string as a Lua chunk.
This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in
the zero-terminated string <code>s</code>.


<p>
This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>.


<p>
Also as <a href="#lua_load"><code>lua_load</code></a>, this function only loads the chunk;
it does not run it.





<hr><h3><a name="luaL_newlib"><code>luaL_newlib</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_newlib (lua_State *L, const luaL_Reg l[]);</pre>

<p>
Creates a new table and registers there
the functions in list <code>l</code>.


<p>
It is implemented as the following macro:

<pre>
     (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
</pre><p>
The array <code>l</code> must be the actual array,
not a pointer to it.





<hr><h3><a name="luaL_newlibtable"><code>luaL_newlibtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_newlibtable (lua_State *L, const luaL_Reg l[]);</pre>

<p>
Creates a new table with a size optimized
to store all entries in the array <code>l</code>
(but does not actually store them).
It is intended to be used in conjunction with <a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>
(see <a href="#luaL_newlib"><code>luaL_newlib</code></a>).


<p>
It is implemented as a macro.
The array <code>l</code> must be the actual array,
not a pointer to it.





<hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_newmetatable (lua_State *L, const char *tname);</pre>

<p>
If the registry already has the key <code>tname</code>,
returns 0.
Otherwise,
creates a new table to be used as a metatable for userdata,
adds to this new table the pair <code>__name = tname</code>,
adds to the registry the pair <code>[tname] = new table</code>,
and returns 1.
(The entry <code>__name</code> is used by some error-reporting functions.)


<p>
In both cases pushes onto the stack the final value associated
with <code>tname</code> in the registry.





<hr><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *luaL_newstate (void);</pre>

<p>
Creates a new Lua state.
It calls <a href="#lua_newstate"><code>lua_newstate</code></a> with an
allocator based on the standard&nbsp;C <code>realloc</code> function
and then sets a panic function (see <a href="#4.6">&sect;4.6</a>) that prints
an error message to the standard error output in case of fatal
errors.


<p>
Returns the new state,
or <code>NULL</code> if there is a memory allocation error.





<hr><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void luaL_openlibs (lua_State *L);</pre>

<p>
Opens all standard Lua libraries into the given state.





<hr><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_optinteger (lua_State *L,
                             int arg,
                             lua_Integer d);</pre>

<p>
If the function argument <code>arg</code> is an integer
(or convertible to an integer),
returns this integer.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.





<hr><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optlstring (lua_State *L,
                             int arg,
                             const char *d,
                             size_t *l);</pre>

<p>
If the function argument <code>arg</code> is a string,
returns this string.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.


<p>
If <code>l</code> is not <code>NULL</code>,
fills the position <code>*l</code> with the result's length.





<hr><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number d);</pre>

<p>
If the function argument <code>arg</code> is a number,
returns this number.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.





<hr><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optstring (lua_State *L,
                            int arg,
                            const char *d);</pre>

<p>
If the function argument <code>arg</code> is a string,
returns this string.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.





<hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>char *luaL_prepbuffer (luaL_Buffer *B);</pre>

<p>
Equivalent to <a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>
with the predefined size <a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE</code></a>.





<hr><h3><a name="luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz);</pre>

<p>
Returns an address to a space of size <code>sz</code>
where you can copy a string to be added to buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
After copying the string into this space you must call
<a href="#luaL_addsize"><code>luaL_addsize</code></a> with the size of the string to actually add
it to the buffer.





<hr><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3><p>
<span class="apii">[-?, +1, <em>e</em>]</span>
<pre>void luaL_pushresult (luaL_Buffer *B);</pre>

<p>
Finishes the use of buffer <code>B</code> leaving the final string on
the top of the stack.





<hr><h3><a name="luaL_pushresultsize"><code>luaL_pushresultsize</code></a></h3><p>
<span class="apii">[-?, +1, <em>e</em>]</span>
<pre>void luaL_pushresultsize (luaL_Buffer *B, size_t sz);</pre>

<p>
Equivalent to the sequence <a href="#luaL_addsize"><code>luaL_addsize</code></a>, <a href="#luaL_pushresult"><code>luaL_pushresult</code></a>.





<hr><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>int luaL_ref (lua_State *L, int t);</pre>

<p>
Creates and returns a <em>reference</em>,
in the table at index <code>t</code>,
for the object at the top of the stack (and pops the object).


<p>
A reference is a unique integer key.
As long as you do not manually add integer keys into table <code>t</code>,
<a href="#luaL_ref"><code>luaL_ref</code></a> ensures the uniqueness of the key it returns.
You can retrieve an object referred by reference <code>r</code>
by calling <code>lua_rawgeti(L, t, r)</code>.
Function <a href="#luaL_unref"><code>luaL_unref</code></a> frees a reference and its associated object.


<p>
If the object at the top of the stack is <b>nil</b>,
<a href="#luaL_ref"><code>luaL_ref</code></a> returns the constant <a name="pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>.
The constant <a name="pdf-LUA_NOREF"><code>LUA_NOREF</code></a> is guaranteed to be different
from any reference returned by <a href="#luaL_ref"><code>luaL_ref</code></a>.





<hr><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3>
<pre>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre>

<p>
Type for arrays of functions to be registered by
<a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>.
<code>name</code> is the function name and <code>func</code> is a pointer to
the function.
Any array of <a href="#luaL_Reg"><code>luaL_Reg</code></a> must end with a sentinel entry
in which both <code>name</code> and <code>func</code> are <code>NULL</code>.





<hr><h3><a name="luaL_requiref"><code>luaL_requiref</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_requiref (lua_State *L, const char *modname,
                    lua_CFunction openf, int glb);</pre>

<p>
If <code>modname</code> is not already present in <a href="#pdf-package.loaded"><code>package.loaded</code></a>,
calls function <code>openf</code> with string <code>modname</code> as an argument
and sets the call result in <code>package.loaded[modname]</code>,
as if that function has been called through <a href="#pdf-require"><code>require</code></a>.


<p>
If <code>glb</code> is true,
also stores the module into global <code>modname</code>.


<p>
Leaves a copy of the module on the stack.





<hr><h3><a name="luaL_setfuncs"><code>luaL_setfuncs</code></a></h3><p>
<span class="apii">[-nup, +0, <em>e</em>]</span>
<pre>void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup);</pre>

<p>
Registers all functions in the array <code>l</code>
(see <a href="#luaL_Reg"><code>luaL_Reg</code></a>) into the table on the top of the stack
(below optional upvalues, see next).


<p>
When <code>nup</code> is not zero,
all functions are created sharing <code>nup</code> upvalues,
which must be previously pushed on the stack
on top of the library table.
These values are popped from the stack after the registration.





<hr><h3><a name="luaL_setmetatable"><code>luaL_setmetatable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_setmetatable (lua_State *L, const char *tname);</pre>

<p>
Sets the metatable of the object at the top of the stack
as the metatable associated with name <code>tname</code>
in the registry (see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).





<hr><h3><a name="luaL_Stream"><code>luaL_Stream</code></a></h3>
<pre>typedef struct luaL_Stream {
  FILE *f;
  lua_CFunction closef;
} luaL_Stream;</pre>

<p>
The standard representation for file handles,
which is used by the standard I/O library.


<p>
A file handle is implemented as a full userdata,
with a metatable called <code>LUA_FILEHANDLE</code>
(where <code>LUA_FILEHANDLE</code> is a macro with the actual metatable's name).
The metatable is created by the I/O library
(see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).


<p>
This userdata must start with the structure <code>luaL_Stream</code>;
it can contain other data after this initial structure.
Field <code>f</code> points to the corresponding C stream
(or it can be <code>NULL</code> to indicate an incompletely created handle).
Field <code>closef</code> points to a Lua function
that will be called to close the stream
when the handle is closed or collected;
this function receives the file handle as its sole argument and
must return either <b>true</b> (in case of success)
or <b>nil</b> plus an error message (in case of error).
Once Lua calls this field,
the field value is changed to <code>NULL</code>
to signal that the handle is closed.





<hr><h3><a name="luaL_testudata"><code>luaL_testudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void *luaL_testudata (lua_State *L, int arg, const char *tname);</pre>

<p>
This function works like <a href="#luaL_checkudata"><code>luaL_checkudata</code></a>,
except that, when the test fails,
it returns <code>NULL</code> instead of raising an error.





<hr><h3><a name="luaL_tolstring"><code>luaL_tolstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *luaL_tolstring (lua_State *L, int idx, size_t *len);</pre>

<p>
Converts any Lua value at the given index to a C&nbsp;string
in a reasonable format.
The resulting string is pushed onto the stack and also
returned by the function.
If <code>len</code> is not <code>NULL</code>,
the function also sets <code>*len</code> with the string length.


<p>
If the value has a metatable with a <code>"__tostring"</code> field,
then <code>luaL_tolstring</code> calls the corresponding metamethod
with the value as argument,
and uses the result of the call as its result.





<hr><h3><a name="luaL_traceback"><code>luaL_traceback</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
                     int level);</pre>

<p>
Creates and pushes a traceback of the stack <code>L1</code>.
If <code>msg</code> is not <code>NULL</code> it is appended
at the beginning of the traceback.
The <code>level</code> parameter tells at which level
to start the traceback.





<hr><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *luaL_typename (lua_State *L, int index);</pre>

<p>
Returns the name of the type of the value at the given index.





<hr><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_unref (lua_State *L, int t, int ref);</pre>

<p>
Releases reference <code>ref</code> from the table at index <code>t</code>
(see <a href="#luaL_ref"><code>luaL_ref</code></a>).
The entry is removed from the table,
so that the referred object can be collected.
The reference <code>ref</code> is also freed to be used again.


<p>
If <code>ref</code> is <a href="#pdf-LUA_NOREF"><code>LUA_NOREF</code></a> or <a href="#pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>,
<a href="#luaL_unref"><code>luaL_unref</code></a> does nothing.





<hr><h3><a name="luaL_where"><code>luaL_where</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_where (lua_State *L, int lvl);</pre>

<p>
Pushes onto the stack a string identifying the current position
of the control at level <code>lvl</code> in the call stack.
Typically this string has the following format:

<pre>
     <em>chunkname</em>:<em>currentline</em>:
</pre><p>
Level&nbsp;0 is the running function,
level&nbsp;1 is the function that called the running function,
etc.


<p>
This function is used to build a prefix for error messages.







<h1>6 &ndash; <a name="6">Standard Libraries</a></h1>

<p>
The standard Lua libraries provide useful functions
that are implemented directly through the C&nbsp;API.
Some of these functions provide essential services to the language
(e.g., <a href="#pdf-type"><code>type</code></a> and <a href="#pdf-getmetatable"><code>getmetatable</code></a>);
others provide access to "outside" services (e.g., I/O);
and others could be implemented in Lua itself,
but are quite useful or have critical performance requirements that
deserve an implementation in C (e.g., <a href="#pdf-table.sort"><code>table.sort</code></a>).


<p>
All libraries are implemented through the official C&nbsp;API
and are provided as separate C&nbsp;modules.
Currently, Lua has the following standard libraries:

<ul>

<li>basic library (<a href="#6.1">&sect;6.1</a>);</li>

<li>coroutine library (<a href="#6.2">&sect;6.2</a>);</li>

<li>package library (<a href="#6.3">&sect;6.3</a>);</li>

<li>string manipulation (<a href="#6.4">&sect;6.4</a>);</li>

<li>basic UTF-8 support (<a href="#6.5">&sect;6.5</a>);</li>

<li>table manipulation (<a href="#6.6">&sect;6.6</a>);</li>

<li>mathematical functions (<a href="#6.7">&sect;6.7</a>) (sin, log, etc.);</li>

<li>input and output (<a href="#6.8">&sect;6.8</a>);</li>

<li>operating system facilities (<a href="#6.9">&sect;6.9</a>);</li>

<li>debug facilities (<a href="#6.10">&sect;6.10</a>).</li>

</ul><p>
Except for the basic and the package libraries,
each library provides all its functions as fields of a global table
or as methods of its objects.


<p>
To have access to these libraries,
the C&nbsp;host program should call the <a href="#luaL_openlibs"><code>luaL_openlibs</code></a> function,
which opens all standard libraries.
Alternatively,
the host program can open them individually by using
<a href="#luaL_requiref"><code>luaL_requiref</code></a> to call
<a name="pdf-luaopen_base"><code>luaopen_base</code></a> (for the basic library),
<a name="pdf-luaopen_package"><code>luaopen_package</code></a> (for the package library),
<a name="pdf-luaopen_coroutine"><code>luaopen_coroutine</code></a> (for the coroutine library),
<a name="pdf-luaopen_string"><code>luaopen_string</code></a> (for the string library),
<a name="pdf-luaopen_utf8"><code>luaopen_utf8</code></a> (for the UTF8 library),
<a name="pdf-luaopen_table"><code>luaopen_table</code></a> (for the table library),
<a name="pdf-luaopen_math"><code>luaopen_math</code></a> (for the mathematical library),
<a name="pdf-luaopen_io"><code>luaopen_io</code></a> (for the I/O library),
<a name="pdf-luaopen_os"><code>luaopen_os</code></a> (for the operating system library),
and <a name="pdf-luaopen_debug"><code>luaopen_debug</code></a> (for the debug library).
These functions are declared in <a name="pdf-lualib.h"><code>lualib.h</code></a>.



<h2>6.1 &ndash; <a name="6.1">Basic Functions</a></h2>

<p>
The basic library provides core functions to Lua.
If you do not include this library in your application,
you should check carefully whether you need to provide
implementations for some of its facilities.


<p>
<hr><h3><a name="pdf-assert"><code>assert (v [, message])</code></a></h3>


<p>
Calls <a href="#pdf-error"><code>error</code></a> if
the value of its argument <code>v</code> is false (i.e., <b>nil</b> or <b>false</b>);
otherwise, returns all its arguments.
In case of error,
<code>message</code> is the error object;
when absent, it defaults to "<code>assertion failed!</code>"




<p>
<hr><h3><a name="pdf-collectgarbage"><code>collectgarbage ([opt [, arg]])</code></a></h3>


<p>
This function is a generic interface to the garbage collector.
It performs different functions according to its first argument, <code>opt</code>:

<ul>

<li><b>"<code>collect</code>": </b>
performs a full garbage-collection cycle.
This is the default option.
</li>

<li><b>"<code>stop</code>": </b>
stops automatic execution of the garbage collector.
The collector will run only when explicitly invoked,
until a call to restart it.
</li>

<li><b>"<code>restart</code>": </b>
restarts automatic execution of the garbage collector.
</li>

<li><b>"<code>count</code>": </b>
returns the total memory in use by Lua in Kbytes.
The value has a fractional part,
so that it multiplied by 1024
gives the exact number of bytes in use by Lua
(except for overflows).
</li>

<li><b>"<code>step</code>": </b>
performs a garbage-collection step.
The step "size" is controlled by <code>arg</code>.
With a zero value,
the collector will perform one basic (indivisible) step.
For non-zero values,
the collector will perform as if that amount of memory
(in KBytes) had been allocated by Lua.
Returns <b>true</b> if the step finished a collection cycle.
</li>

<li><b>"<code>setpause</code>": </b>
sets <code>arg</code> as the new value for the <em>pause</em> of
the collector (see <a href="#2.5">&sect;2.5</a>).
Returns the previous value for <em>pause</em>.
</li>

<li><b>"<code>setstepmul</code>": </b>
sets <code>arg</code> as the new value for the <em>step multiplier</em> of
the collector (see <a href="#2.5">&sect;2.5</a>).
Returns the previous value for <em>step</em>.
</li>

<li><b>"<code>isrunning</code>": </b>
returns a boolean that tells whether the collector is running
(i.e., not stopped).
</li>

</ul>



<p>
<hr><h3><a name="pdf-dofile"><code>dofile ([filename])</code></a></h3>
Opens the named file and executes its contents as a Lua chunk.
When called without arguments,
<code>dofile</code> executes the contents of the standard input (<code>stdin</code>).
Returns all values returned by the chunk.
In case of errors, <code>dofile</code> propagates the error
to its caller (that is, <code>dofile</code> does not run in protected mode).




<p>
<hr><h3><a name="pdf-error"><code>error (message [, level])</code></a></h3>
Terminates the last protected function called
and returns <code>message</code> as the error object.
Function <code>error</code> never returns.


<p>
Usually, <code>error</code> adds some information about the error position
at the beginning of the message, if the message is a string.
The <code>level</code> argument specifies how to get the error position.
With level&nbsp;1 (the default), the error position is where the
<code>error</code> function was called.
Level&nbsp;2 points the error to where the function
that called <code>error</code> was called; and so on.
Passing a level&nbsp;0 avoids the addition of error position information
to the message.




<p>
<hr><h3><a name="pdf-_G"><code>_G</code></a></h3>
A global variable (not a function) that
holds the global environment (see <a href="#2.2">&sect;2.2</a>).
Lua itself does not use this variable;
changing its value does not affect any environment,
nor vice versa.




<p>
<hr><h3><a name="pdf-getmetatable"><code>getmetatable (object)</code></a></h3>


<p>
If <code>object</code> does not have a metatable, returns <b>nil</b>.
Otherwise,
if the object's metatable has a <code>"__metatable"</code> field,
returns the associated value.
Otherwise, returns the metatable of the given object.




<p>
<hr><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3>


<p>
Returns three values (an iterator function, the table <code>t</code>, and 0)
so that the construction

<pre>
     for i,v in ipairs(t) do <em>body</em> end
</pre><p>
will iterate over the key&ndash;value pairs
(<code>1,t[1]</code>), (<code>2,t[2]</code>), ...,
up to the first nil value.




<p>
<hr><h3><a name="pdf-load"><code>load (chunk [, chunkname [, mode [, env]]])</code></a></h3>


<p>
Loads a chunk.


<p>
If <code>chunk</code> is a string, the chunk is this string.
If <code>chunk</code> is a function,
<code>load</code> calls it repeatedly to get the chunk pieces.
Each call to <code>chunk</code> must return a string that concatenates
with previous results.
A return of an empty string, <b>nil</b>, or no value signals the end of the chunk.


<p>
If there are no syntactic errors,
returns the compiled chunk as a function;
otherwise, returns <b>nil</b> plus the error message.


<p>
If the resulting function has upvalues,
the first upvalue is set to the value of <code>env</code>,
if that parameter is given,
or to the value of the global environment.
Other upvalues are initialized with <b>nil</b>.
(When you load a main chunk,
the resulting function will always have exactly one upvalue,
the <code>_ENV</code> variable (see <a href="#2.2">&sect;2.2</a>).
However,
when you load a binary chunk created from a function (see <a href="#pdf-string.dump"><code>string.dump</code></a>),
the resulting function can have an arbitrary number of upvalues.)
All upvalues are fresh, that is,
they are not shared with any other function.


<p>
<code>chunkname</code> is used as the name of the chunk for error messages
and debug information (see <a href="#4.9">&sect;4.9</a>).
When absent,
it defaults to <code>chunk</code>, if <code>chunk</code> is a string,
or to "<code>=(load)</code>" otherwise.


<p>
The string <code>mode</code> controls whether the chunk can be text or binary
(that is, a precompiled chunk).
It may be the string "<code>b</code>" (only binary chunks),
"<code>t</code>" (only text chunks),
or "<code>bt</code>" (both binary and text).
The default is "<code>bt</code>".


<p>
Lua does not check the consistency of binary chunks.
Maliciously crafted binary chunks can crash
the interpreter.




<p>
<hr><h3><a name="pdf-loadfile"><code>loadfile ([filename [, mode [, env]]])</code></a></h3>


<p>
Similar to <a href="#pdf-load"><code>load</code></a>,
but gets the chunk from file <code>filename</code>
or from the standard input,
if no file name is given.




<p>
<hr><h3><a name="pdf-next"><code>next (table [, index])</code></a></h3>


<p>
Allows a program to traverse all fields of a table.
Its first argument is a table and its second argument
is an index in this table.
<code>next</code> returns the next index of the table
and its associated value.
When called with <b>nil</b> as its second argument,
<code>next</code> returns an initial index
and its associated value.
When called with the last index,
or with <b>nil</b> in an empty table,
<code>next</code> returns <b>nil</b>.
If the second argument is absent, then it is interpreted as <b>nil</b>.
In particular,
you can use <code>next(t)</code> to check whether a table is empty.


<p>
The order in which the indices are enumerated is not specified,
<em>even for numeric indices</em>.
(To traverse a table in numeric order,
use a numerical <b>for</b>.)


<p>
The behavior of <code>next</code> is undefined if,
during the traversal,
you assign any value to a non-existent field in the table.
You may however modify existing fields.
In particular, you may clear existing fields.




<p>
<hr><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3>


<p>
If <code>t</code> has a metamethod <code>__pairs</code>,
calls it with <code>t</code> as argument and returns the first three
results from the call.


<p>
Otherwise,
returns three values: the <a href="#pdf-next"><code>next</code></a> function, the table <code>t</code>, and <b>nil</b>,
so that the construction

<pre>
     for k,v in pairs(t) do <em>body</em> end
</pre><p>
will iterate over all key&ndash;value pairs of table <code>t</code>.


<p>
See function <a href="#pdf-next"><code>next</code></a> for the caveats of modifying
the table during its traversal.




<p>
<hr><h3><a name="pdf-pcall"><code>pcall (f [, arg1, &middot;&middot;&middot;])</code></a></h3>


<p>
Calls function <code>f</code> with
the given arguments in <em>protected mode</em>.
This means that any error inside&nbsp;<code>f</code> is not propagated;
instead, <code>pcall</code> catches the error
and returns a status code.
Its first result is the status code (a boolean),
which is true if the call succeeds without errors.
In such case, <code>pcall</code> also returns all results from the call,
after this first result.
In case of any error, <code>pcall</code> returns <b>false</b> plus the error message.




<p>
<hr><h3><a name="pdf-print"><code>print (&middot;&middot;&middot;)</code></a></h3>
Receives any number of arguments
and prints their values to <code>stdout</code>,
using the <a href="#pdf-tostring"><code>tostring</code></a> function to convert each argument to a string.
<code>print</code> is not intended for formatted output,
but only as a quick way to show a value,
for instance for debugging.
For complete control over the output,
use <a href="#pdf-string.format"><code>string.format</code></a> and <a href="#pdf-io.write"><code>io.write</code></a>.




<p>
<hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3>
Checks whether <code>v1</code> is equal to <code>v2</code>,
without invoking any metamethod.
Returns a boolean.




<p>
<hr><h3><a name="pdf-rawget"><code>rawget (table, index)</code></a></h3>
Gets the real value of <code>table[index]</code>,
without invoking any metamethod.
<code>table</code> must be a table;
<code>index</code> may be any value.




<p>
<hr><h3><a name="pdf-rawlen"><code>rawlen (v)</code></a></h3>
Returns the length of the object <code>v</code>,
which must be a table or a string,
without invoking any metamethod.
Returns an integer.




<p>
<hr><h3><a name="pdf-rawset"><code>rawset (table, index, value)</code></a></h3>
Sets the real value of <code>table[index]</code> to <code>value</code>,
without invoking any metamethod.
<code>table</code> must be a table,
<code>index</code> any value different from <b>nil</b> and NaN,
and <code>value</code> any Lua value.


<p>
This function returns <code>table</code>.




<p>
<hr><h3><a name="pdf-select"><code>select (index, &middot;&middot;&middot;)</code></a></h3>


<p>
If <code>index</code> is a number,
returns all arguments after argument number <code>index</code>;
a negative number indexes from the end (-1 is the last argument).
Otherwise, <code>index</code> must be the string <code>"#"</code>,
and <code>select</code> returns the total number of extra arguments it received.




<p>
<hr><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)</code></a></h3>


<p>
Sets the metatable for the given table.
(You cannot change the metatable of other types from Lua, only from&nbsp;C.)
If <code>metatable</code> is <b>nil</b>,
removes the metatable of the given table.
If the original metatable has a <code>"__metatable"</code> field,
raises an error.


<p>
This function returns <code>table</code>.




<p>
<hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3>


<p>
When called with no <code>base</code>,
<code>tonumber</code> tries to convert its argument to a number.
If the argument is already a number or
a string convertible to a number,
then <code>tonumber</code> returns this number;
otherwise, it returns <b>nil</b>.


<p>
The conversion of strings can result in integers or floats,
according to the lexical conventions of Lua (see <a href="#3.1">&sect;3.1</a>).
(The string may have leading and trailing spaces and a sign.)


<p>
When called with <code>base</code>,
then <code>e</code> must be a string to be interpreted as
an integer numeral in that base.
The base may be any integer between 2 and 36, inclusive.
In bases above&nbsp;10, the letter '<code>A</code>' (in either upper or lower case)
represents&nbsp;10, '<code>B</code>' represents&nbsp;11, and so forth,
with '<code>Z</code>' representing 35.
If the string <code>e</code> is not a valid numeral in the given base,
the function returns <b>nil</b>.




<p>
<hr><h3><a name="pdf-tostring"><code>tostring (v)</code></a></h3>
Receives a value of any type and
converts it to a string in a human-readable format.
Floats always produce strings with some
floating-point indication (either a decimal dot or an exponent).
(For complete control of how numbers are converted,
use <a href="#pdf-string.format"><code>string.format</code></a>.)


<p>
If the metatable of <code>v</code> has a <code>"__tostring"</code> field,
then <code>tostring</code> calls the corresponding value
with <code>v</code> as argument,
and uses the result of the call as its result.




<p>
<hr><h3><a name="pdf-type"><code>type (v)</code></a></h3>
Returns the type of its only argument, coded as a string.
The possible results of this function are
"<code>nil</code>" (a string, not the value <b>nil</b>),
"<code>number</code>",
"<code>string</code>",
"<code>boolean</code>",
"<code>table</code>",
"<code>function</code>",
"<code>thread</code>",
and "<code>userdata</code>".




<p>
<hr><h3><a name="pdf-_VERSION"><code>_VERSION</code></a></h3>
A global variable (not a function) that
holds a string containing the current interpreter version.
The current value of this variable is "<code>Lua 5.3</code>".




<p>
<hr><h3><a name="pdf-xpcall"><code>xpcall (f, msgh [, arg1, &middot;&middot;&middot;])</code></a></h3>


<p>
This function is similar to <a href="#pdf-pcall"><code>pcall</code></a>,
except that it sets a new message handler <code>msgh</code>.







<h2>6.2 &ndash; <a name="6.2">Coroutine Manipulation</a></h2>

<p>
The operations related to coroutines comprise a sub-library of
the basic library and come inside the table <a name="pdf-coroutine"><code>coroutine</code></a>.
See <a href="#2.6">&sect;2.6</a> for a general description of coroutines.


<p>
<hr><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)</code></a></h3>


<p>
Creates a new coroutine, with body <code>f</code>.
<code>f</code> must be a Lua function.
Returns this new coroutine,
an object with type <code>"thread"</code>.




<p>
<hr><h3><a name="pdf-coroutine.isyieldable"><code>coroutine.isyieldable ()</code></a></h3>


<p>
Returns true when the running coroutine can yield.


<p>
A running coroutine is yieldable if it is not the main thread and
it is not inside a non-yieldable C function.




<p>
<hr><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, &middot;&middot;&middot;])</code></a></h3>


<p>
Starts or continues the execution of coroutine <code>co</code>.
The first time you resume a coroutine,
it starts running its body.
The values <code>val1</code>, ... are passed
as the arguments to the body function.
If the coroutine has yielded,
<code>resume</code> restarts it;
the values <code>val1</code>, ... are passed
as the results from the yield.


<p>
If the coroutine runs without any errors,
<code>resume</code> returns <b>true</b> plus any values passed to <code>yield</code>
(when the coroutine yields) or any values returned by the body function
(when the coroutine terminates).
If there is any error,
<code>resume</code> returns <b>false</b> plus the error message.




<p>
<hr><h3><a name="pdf-coroutine.running"><code>coroutine.running ()</code></a></h3>


<p>
Returns the running coroutine plus a boolean,
true when the running coroutine is the main one.




<p>
<hr><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)</code></a></h3>


<p>
Returns the status of coroutine <code>co</code>, as a string:
<code>"running"</code>,
if the coroutine is running (that is, it called <code>status</code>);
<code>"suspended"</code>, if the coroutine is suspended in a call to <code>yield</code>,
or if it has not started running yet;
<code>"normal"</code> if the coroutine is active but not running
(that is, it has resumed another coroutine);
and <code>"dead"</code> if the coroutine has finished its body function,
or if it has stopped with an error.




<p>
<hr><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)</code></a></h3>


<p>
Creates a new coroutine, with body <code>f</code>.
<code>f</code> must be a Lua function.
Returns a function that resumes the coroutine each time it is called.
Any arguments passed to the function behave as the
extra arguments to <code>resume</code>.
Returns the same values returned by <code>resume</code>,
except the first boolean.
In case of error, propagates the error.




<p>
<hr><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (&middot;&middot;&middot;)</code></a></h3>


<p>
Suspends the execution of the calling coroutine.
Any arguments to <code>yield</code> are passed as extra results to <code>resume</code>.







<h2>6.3 &ndash; <a name="6.3">Modules</a></h2>

<p>
The package library provides basic
facilities for loading modules in Lua.
It exports one function directly in the global environment:
<a href="#pdf-require"><code>require</code></a>.
Everything else is exported in a table <a name="pdf-package"><code>package</code></a>.


<p>
<hr><h3><a name="pdf-require"><code>require (modname)</code></a></h3>


<p>
Loads the given module.
The function starts by looking into the <a href="#pdf-package.loaded"><code>package.loaded</code></a> table
to determine whether <code>modname</code> is already loaded.
If it is, then <code>require</code> returns the value stored
at <code>package.loaded[modname]</code>.
Otherwise, it tries to find a <em>loader</em> for the module.


<p>
To find a loader,
<code>require</code> is guided by the <a href="#pdf-package.searchers"><code>package.searchers</code></a> sequence.
By changing this sequence,
we can change how <code>require</code> looks for a module.
The following explanation is based on the default configuration
for <a href="#pdf-package.searchers"><code>package.searchers</code></a>.


<p>
First <code>require</code> queries <code>package.preload[modname]</code>.
If it has a value,
this value (which must be a function) is the loader.
Otherwise <code>require</code> searches for a Lua loader using the
path stored in <a href="#pdf-package.path"><code>package.path</code></a>.
If that also fails, it searches for a C&nbsp;loader using the
path stored in <a href="#pdf-package.cpath"><code>package.cpath</code></a>.
If that also fails,
it tries an <em>all-in-one</em> loader (see <a href="#pdf-package.searchers"><code>package.searchers</code></a>).


<p>
Once a loader is found,
<code>require</code> calls the loader with two arguments:
<code>modname</code> and an extra value dependent on how it got the loader.
(If the loader came from a file,
this extra value is the file name.)
If the loader returns any non-nil value,
<code>require</code> assigns the returned value to <code>package.loaded[modname]</code>.
If the loader does not return a non-nil value and
has not assigned any value to <code>package.loaded[modname]</code>,
then <code>require</code> assigns <b>true</b> to this entry.
In any case, <code>require</code> returns the
final value of <code>package.loaded[modname]</code>.


<p>
If there is any error loading or running the module,
or if it cannot find any loader for the module,
then <code>require</code> raises an error.




<p>
<hr><h3><a name="pdf-package.config"><code>package.config</code></a></h3>


<p>
A string describing some compile-time configurations for packages.
This string is a sequence of lines:

<ul>

<li>The first line is the directory separator string.
Default is '<code>\</code>' for Windows and '<code>/</code>' for all other systems.</li>

<li>The second line is the character that separates templates in a path.
Default is '<code>;</code>'.</li>

<li>The third line is the string that marks the
substitution points in a template.
Default is '<code>?</code>'.</li>

<li>The fourth line is a string that, in a path in Windows,
is replaced by the executable's directory.
Default is '<code>!</code>'.</li>

<li>The fifth line is a mark to ignore all text after it
when building the <code>luaopen_</code> function name.
Default is '<code>-</code>'.</li>

</ul>



<p>
<hr><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3>


<p>
The path used by <a href="#pdf-require"><code>require</code></a> to search for a C&nbsp;loader.


<p>
Lua initializes the C&nbsp;path <a href="#pdf-package.cpath"><code>package.cpath</code></a> in the same way
it initializes the Lua path <a href="#pdf-package.path"><code>package.path</code></a>,
using the environment variable <a name="pdf-LUA_CPATH_5_3"><code>LUA_CPATH_5_3</code></a>
or the environment variable <a name="pdf-LUA_CPATH"><code>LUA_CPATH</code></a>
or a default path defined in <code>luaconf.h</code>.




<p>
<hr><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3>


<p>
A table used by <a href="#pdf-require"><code>require</code></a> to control which
modules are already loaded.
When you require a module <code>modname</code> and
<code>package.loaded[modname]</code> is not false,
<a href="#pdf-require"><code>require</code></a> simply returns the value stored there.


<p>
This variable is only a reference to the real table;
assignments to this variable do not change the
table used by <a href="#pdf-require"><code>require</code></a>.




<p>
<hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>


<p>
Dynamically links the host program with the C&nbsp;library <code>libname</code>.


<p>
If <code>funcname</code> is "<code>*</code>",
then it only links with the library,
making the symbols exported by the library
available to other dynamically linked libraries.
Otherwise,
it looks for a function <code>funcname</code> inside the library
and returns this function as a C&nbsp;function.
So, <code>funcname</code> must follow the <a href="#lua_CFunction"><code>lua_CFunction</code></a> prototype
(see <a href="#lua_CFunction"><code>lua_CFunction</code></a>).


<p>
This is a low-level function.
It completely bypasses the package and module system.
Unlike <a href="#pdf-require"><code>require</code></a>,
it does not perform any path searching and
does not automatically adds extensions.
<code>libname</code> must be the complete file name of the C&nbsp;library,
including if necessary a path and an extension.
<code>funcname</code> must be the exact name exported by the C&nbsp;library
(which may depend on the C&nbsp;compiler and linker used).


<p>
This function is not supported by Standard&nbsp;C.
As such, it is only available on some platforms
(Windows, Linux, Mac OS X, Solaris, BSD,
plus other Unix systems that support the <code>dlfcn</code> standard).




<p>
<hr><h3><a name="pdf-package.path"><code>package.path</code></a></h3>


<p>
The path used by <a href="#pdf-require"><code>require</code></a> to search for a Lua loader.


<p>
At start-up, Lua initializes this variable with
the value of the environment variable <a name="pdf-LUA_PATH_5_3"><code>LUA_PATH_5_3</code></a> or
the environment variable <a name="pdf-LUA_PATH"><code>LUA_PATH</code></a> or
with a default path defined in <code>luaconf.h</code>,
if those environment variables are not defined.
Any "<code>;;</code>" in the value of the environment variable
is replaced by the default path.




<p>
<hr><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3>


<p>
A table to store loaders for specific modules
(see <a href="#pdf-require"><code>require</code></a>).


<p>
This variable is only a reference to the real table;
assignments to this variable do not change the
table used by <a href="#pdf-require"><code>require</code></a>.




<p>
<hr><h3><a name="pdf-package.searchers"><code>package.searchers</code></a></h3>


<p>
A table used by <a href="#pdf-require"><code>require</code></a> to control how to load modules.


<p>
Each entry in this table is a <em>searcher function</em>.
When looking for a module,
<a href="#pdf-require"><code>require</code></a> calls each of these searchers in ascending order,
with the module name (the argument given to <a href="#pdf-require"><code>require</code></a>) as its
sole parameter.
The function can return another function (the module <em>loader</em>)
plus an extra value that will be passed to that loader,
or a string explaining why it did not find that module
(or <b>nil</b> if it has nothing to say).


<p>
Lua initializes this table with four searcher functions.


<p>
The first searcher simply looks for a loader in the
<a href="#pdf-package.preload"><code>package.preload</code></a> table.


<p>
The second searcher looks for a loader as a Lua library,
using the path stored at <a href="#pdf-package.path"><code>package.path</code></a>.
The search is done as described in function <a href="#pdf-package.searchpath"><code>package.searchpath</code></a>.


<p>
The third searcher looks for a loader as a C&nbsp;library,
using the path given by the variable <a href="#pdf-package.cpath"><code>package.cpath</code></a>.
Again,
the search is done as described in function <a href="#pdf-package.searchpath"><code>package.searchpath</code></a>.
For instance,
if the C&nbsp;path is the string

<pre>
     "./?.so;./?.dll;/usr/local/?/init.so"
</pre><p>
the searcher for module <code>foo</code>
will try to open the files <code>./foo.so</code>, <code>./foo.dll</code>,
and <code>/usr/local/foo/init.so</code>, in that order.
Once it finds a C&nbsp;library,
this searcher first uses a dynamic link facility to link the
application with the library.
Then it tries to find a C&nbsp;function inside the library to
be used as the loader.
The name of this C&nbsp;function is the string "<code>luaopen_</code>"
concatenated with a copy of the module name where each dot
is replaced by an underscore.
Moreover, if the module name has a hyphen,
its suffix after (and including) the first hyphen is removed.
For instance, if the module name is <code>a.b.c-v2.1</code>,
the function name will be <code>luaopen_a_b_c</code>.


<p>
The fourth searcher tries an <em>all-in-one loader</em>.
It searches the C&nbsp;path for a library for
the root name of the given module.
For instance, when requiring <code>a.b.c</code>,
it will search for a C&nbsp;library for <code>a</code>.
If found, it looks into it for an open function for
the submodule;
in our example, that would be <code>luaopen_a_b_c</code>.
With this facility, a package can pack several C&nbsp;submodules
into one single library,
with each submodule keeping its original open function.


<p>
All searchers except the first one (preload) return as the extra value
the file name where the module was found,
as returned by <a href="#pdf-package.searchpath"><code>package.searchpath</code></a>.
The first searcher returns no extra value.




<p>
<hr><h3><a name="pdf-package.searchpath"><code>package.searchpath (name, path [, sep [, rep]])</code></a></h3>


<p>
Searches for the given <code>name</code> in the given <code>path</code>.


<p>
A path is a string containing a sequence of
<em>templates</em> separated by semicolons.
For each template,
the function replaces each interrogation mark (if any)
in the template with a copy of <code>name</code>
wherein all occurrences of <code>sep</code>
(a dot, by default)
were replaced by <code>rep</code>
(the system's directory separator, by default),
and then tries to open the resulting file name.


<p>
For instance, if the path is the string

<pre>
     "./?.lua;./?.lc;/usr/local/?/init.lua"
</pre><p>
the search for the name <code>foo.a</code>
will try to open the files
<code>./foo/a.lua</code>, <code>./foo/a.lc</code>, and
<code>/usr/local/foo/a/init.lua</code>, in that order.


<p>
Returns the resulting name of the first file that it can
open in read mode (after closing the file),
or <b>nil</b> plus an error message if none succeeds.
(This error message lists all file names it tried to open.)







<h2>6.4 &ndash; <a name="6.4">String Manipulation</a></h2>

<p>
This library provides generic functions for string manipulation,
such as finding and extracting substrings, and pattern matching.
When indexing a string in Lua, the first character is at position&nbsp;1
(not at&nbsp;0, as in C).
Indices are allowed to be negative and are interpreted as indexing backwards,
from the end of the string.
Thus, the last character is at position -1, and so on.


<p>
The string library provides all its functions inside the table
<a name="pdf-string"><code>string</code></a>.
It also sets a metatable for strings
where the <code>__index</code> field points to the <code>string</code> table.
Therefore, you can use the string functions in object-oriented style.
For instance, <code>string.byte(s,i)</code>
can be written as <code>s:byte(i)</code>.


<p>
The string library assumes one-byte character encodings.


<p>
<hr><h3><a name="pdf-string.byte"><code>string.byte (s [, i [, j]])</code></a></h3>
Returns the internal numerical codes of the characters <code>s[i]</code>,
<code>s[i+1]</code>, ..., <code>s[j]</code>.
The default value for <code>i</code> is&nbsp;1;
the default value for <code>j</code> is&nbsp;<code>i</code>.
These indices are corrected
following the same rules of function <a href="#pdf-string.sub"><code>string.sub</code></a>.


<p>
Numerical codes are not necessarily portable across platforms.




<p>
<hr><h3><a name="pdf-string.char"><code>string.char (&middot;&middot;&middot;)</code></a></h3>
Receives zero or more integers.
Returns a string with length equal to the number of arguments,
in which each character has the internal numerical code equal
to its corresponding argument.


<p>
Numerical codes are not necessarily portable across platforms.




<p>
<hr><h3><a name="pdf-string.dump"><code>string.dump (function [, strip])</code></a></h3>


<p>
Returns a string containing a binary representation
(a <em>binary chunk</em>)
of the given function,
so that a later <a href="#pdf-load"><code>load</code></a> on this string returns
a copy of the function (but with new upvalues).
If <code>strip</code> is a true value,
the binary representation is created without debug information
about the function
(local variable names, lines, etc.).


<p>
Functions with upvalues have only their number of upvalues saved.
When (re)loaded,
those upvalues receive fresh instances containing <b>nil</b>.
(You can use the debug library to serialize
and reload the upvalues of a function
in a way adequate to your needs.)




<p>
<hr><h3><a name="pdf-string.find"><code>string.find (s, pattern [, init [, plain]])</code></a></h3>


<p>
Looks for the first match of
<code>pattern</code> (see <a href="#6.4.1">&sect;6.4.1</a>) in the string <code>s</code>.
If it finds a match, then <code>find</code> returns the indices of&nbsp;<code>s</code>
where this occurrence starts and ends;
otherwise, it returns <b>nil</b>.
A third, optional numerical argument <code>init</code> specifies
where to start the search;
its default value is&nbsp;1 and can be negative.
A value of <b>true</b> as a fourth, optional argument <code>plain</code>
turns off the pattern matching facilities,
so the function does a plain "find substring" operation,
with no characters in <code>pattern</code> being considered magic.
Note that if <code>plain</code> is given, then <code>init</code> must be given as well.


<p>
If the pattern has captures,
then in a successful match
the captured values are also returned,
after the two indices.




<p>
<hr><h3><a name="pdf-string.format"><code>string.format (formatstring, &middot;&middot;&middot;)</code></a></h3>


<p>
Returns a formatted version of its variable number of arguments
following the description given in its first argument (which must be a string).
The format string follows the same rules as the ISO&nbsp;C function <code>sprintf</code>.
The only differences are that the options/modifiers
<code>*</code>, <code>h</code>, <code>L</code>, <code>l</code>, <code>n</code>,
and <code>p</code> are not supported
and that there is an extra option, <code>q</code>.
The <code>q</code> option formats a string between double quotes,
using escape sequences when necessary to ensure that
it can safely be read back by the Lua interpreter.
For instance, the call

<pre>
     string.format('%q', 'a string with "quotes" and \n new line')
</pre><p>
may produce the string:

<pre>
     "a string with \"quotes\" and \
      new line"
</pre>

<p>
Options
<code>A</code> and <code>a</code> (when available),
<code>E</code>, <code>e</code>, <code>f</code>,
<code>G</code>, and <code>g</code> all expect a number as argument.
Options <code>c</code>, <code>d</code>,
<code>i</code>, <code>o</code>, <code>u</code>, <code>X</code>, and <code>x</code>
expect an integer.
Option <code>q</code> expects a string;
option <code>s</code> expects a string without embedded zeros.
If the argument to option <code>s</code> is not a string,
it is converted to one following the same rules of <a href="#pdf-tostring"><code>tostring</code></a>.




<p>
<hr><h3><a name="pdf-string.gmatch"><code>string.gmatch (s, pattern)</code></a></h3>
Returns an iterator function that,
each time it is called,
returns the next captures from <code>pattern</code> (see <a href="#6.4.1">&sect;6.4.1</a>)
over the string <code>s</code>.
If <code>pattern</code> specifies no captures,
then the whole match is produced in each call.


<p>
As an example, the following loop
will iterate over all the words from string <code>s</code>,
printing one per line:

<pre>
     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end
</pre><p>
The next example collects all pairs <code>key=value</code> from the
given string into a table:

<pre>
     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "(%w+)=(%w+)") do
       t[k] = v
     end
</pre>

<p>
For this function, a caret '<code>^</code>' at the start of a pattern does not
work as an anchor, as this would prevent the iteration.




<p>
<hr><h3><a name="pdf-string.gsub"><code>string.gsub (s, pattern, repl [, n])</code></a></h3>
Returns a copy of <code>s</code>
in which all (or the first <code>n</code>, if given)
occurrences of the <code>pattern</code> (see <a href="#6.4.1">&sect;6.4.1</a>) have been
replaced by a replacement string specified by <code>repl</code>,
which can be a string, a table, or a function.
<code>gsub</code> also returns, as its second value,
the total number of matches that occurred.
The name <code>gsub</code> comes from <em>Global SUBstitution</em>.


<p>
If <code>repl</code> is a string, then its value is used for replacement.
The character&nbsp;<code>%</code> works as an escape character:
any sequence in <code>repl</code> of the form <code>%<em>d</em></code>,
with <em>d</em> between 1 and 9,
stands for the value of the <em>d</em>-th captured substring.
The sequence <code>%0</code> stands for the whole match.
The sequence <code>%%</code> stands for a single&nbsp;<code>%</code>.


<p>
If <code>repl</code> is a table, then the table is queried for every match,
using the first capture as the key.


<p>
If <code>repl</code> is a function, then this function is called every time a
match occurs, with all captured substrings passed as arguments,
in order.


<p>
In any case,
if the pattern specifies no captures,
then it behaves as if the whole pattern was inside a capture.


<p>
If the value returned by the table query or by the function call
is a string or a number,
then it is used as the replacement string;
otherwise, if it is <b>false</b> or <b>nil</b>,
then there is no replacement
(that is, the original match is kept in the string).


<p>
Here are some examples:

<pre>
     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --&gt; x="hello hello world world"
     
     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --&gt; x="hello hello world"
     
     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --&gt; x="world hello Lua from"
     
     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --&gt; x="home = /home/roberto, user = roberto"
     
     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return load(s)()
         end)
     --&gt; x="4+5 = 9"
     
     local t = {name="lua", version="5.3"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --&gt; x="lua-5.3.tar.gz"
</pre>



<p>
<hr><h3><a name="pdf-string.len"><code>string.len (s)</code></a></h3>
Receives a string and returns its length.
The empty string <code>""</code> has length 0.
Embedded zeros are counted,
so <code>"a\000bc\000"</code> has length 5.




<p>
<hr><h3><a name="pdf-string.lower"><code>string.lower (s)</code></a></h3>
Receives a string and returns a copy of this string with all
uppercase letters changed to lowercase.
All other characters are left unchanged.
The definition of what an uppercase letter is depends on the current locale.




<p>
<hr><h3><a name="pdf-string.match"><code>string.match (s, pattern [, init])</code></a></h3>
Looks for the first <em>match</em> of
<code>pattern</code> (see <a href="#6.4.1">&sect;6.4.1</a>) in the string <code>s</code>.
If it finds one, then <code>match</code> returns
the captures from the pattern;
otherwise it returns <b>nil</b>.
If <code>pattern</code> specifies no captures,
then the whole match is returned.
A third, optional numerical argument <code>init</code> specifies
where to start the search;
its default value is&nbsp;1 and can be negative.




<p>
<hr><h3><a name="pdf-string.pack"><code>string.pack (fmt, v1, v2, &middot;&middot;&middot;)</code></a></h3>


<p>
Returns a binary string containing the values <code>v1</code>, <code>v2</code>, etc.
packed (that is, serialized in binary form)
according to the format string <code>fmt</code> (see <a href="#6.4.2">&sect;6.4.2</a>). 




<p>
<hr><h3><a name="pdf-string.packsize"><code>string.packsize (fmt)</code></a></h3>


<p>
Returns the size of a string resulting from <a href="#pdf-string.pack"><code>string.pack</code></a>
with the given format.
The format string cannot have the variable-length options
'<code>s</code>' or '<code>z</code>' (see <a href="#6.4.2">&sect;6.4.2</a>).




<p>
<hr><h3><a name="pdf-string.rep"><code>string.rep (s, n [, sep])</code></a></h3>
Returns a string that is the concatenation of <code>n</code> copies of
the string <code>s</code> separated by the string <code>sep</code>.
The default value for <code>sep</code> is the empty string
(that is, no separator).
Returns the empty string if <code>n</code> is not positive.




<p>
<hr><h3><a name="pdf-string.reverse"><code>string.reverse (s)</code></a></h3>
Returns a string that is the string <code>s</code> reversed.




<p>
<hr><h3><a name="pdf-string.sub"><code>string.sub (s, i [, j])</code></a></h3>
Returns the substring of <code>s</code> that
starts at <code>i</code>  and continues until <code>j</code>;
<code>i</code> and <code>j</code> can be negative.
If <code>j</code> is absent, then it is assumed to be equal to -1
(which is the same as the string length).
In particular,
the call <code>string.sub(s,1,j)</code> returns a prefix of <code>s</code>
with length <code>j</code>,
and <code>string.sub(s, -i)</code> returns a suffix of <code>s</code>
with length <code>i</code>.


<p>
If, after the translation of negative indices,
<code>i</code> is less than 1,
it is corrected to 1.
If <code>j</code> is greater than the string length,
it is corrected to that length.
If, after these corrections,
<code>i</code> is greater than <code>j</code>,
the function returns the empty string.




<p>
<hr><h3><a name="pdf-string.unpack"><code>string.unpack (fmt, s [, pos])</code></a></h3>


<p>
Returns the values packed in string <code>s</code> (see <a href="#pdf-string.pack"><code>string.pack</code></a>)
according to the format string <code>fmt</code> (see <a href="#6.4.2">&sect;6.4.2</a>).
An optional <code>pos</code> marks where
to start reading in <code>s</code> (default is 1).
After the read values,
this function also returns the index of the first unread byte in <code>s</code>.




<p>
<hr><h3><a name="pdf-string.upper"><code>string.upper (s)</code></a></h3>
Receives a string and returns a copy of this string with all
lowercase letters changed to uppercase.
All other characters are left unchanged.
The definition of what a lowercase letter is depends on the current locale.





<h3>6.4.1 &ndash; <a name="6.4.1">Patterns</a></h3>

<p>
Patterns in Lua are described by regular strings,
which are interpreted as patterns by the pattern-matching functions
<a href="#pdf-string.find"><code>string.find</code></a>,
<a href="#pdf-string.gmatch"><code>string.gmatch</code></a>,
<a href="#pdf-string.gsub"><code>string.gsub</code></a>,
and <a href="#pdf-string.match"><code>string.match</code></a>.
This section describes the syntax and the meaning
(that is, what they match) of these strings.



<h4>Character Class:</h4><p>
A <em>character class</em> is used to represent a set of characters.
The following combinations are allowed in describing a character class:

<ul>

<li><b><em>x</em>: </b>
(where <em>x</em> is not one of the <em>magic characters</em>
<code>^$()%.[]*+-?</code>)
represents the character <em>x</em> itself.
</li>

<li><b><code>.</code>: </b> (a dot) represents all characters.</li>

<li><b><code>%a</code>: </b> represents all letters.</li>

<li><b><code>%c</code>: </b> represents all control characters.</li>

<li><b><code>%d</code>: </b> represents all digits.</li>

<li><b><code>%g</code>: </b> represents all printable characters except space.</li>

<li><b><code>%l</code>: </b> represents all lowercase letters.</li>

<li><b><code>%p</code>: </b> represents all punctuation characters.</li>

<li><b><code>%s</code>: </b> represents all space characters.</li>

<li><b><code>%u</code>: </b> represents all uppercase letters.</li>

<li><b><code>%w</code>: </b> represents all alphanumeric characters.</li>

<li><b><code>%x</code>: </b> represents all hexadecimal digits.</li>

<li><b><code>%<em>x</em></code>: </b> (where <em>x</em> is any non-alphanumeric character)
represents the character <em>x</em>.
This is the standard way to escape the magic characters.
Any non-alphanumeric character
(including all punctuations, even the non-magical)
can be preceded by a '<code>%</code>'
when used to represent itself in a pattern.
</li>

<li><b><code>[<em>set</em>]</code>: </b>
represents the class which is the union of all
characters in <em>set</em>.
A range of characters can be specified by
separating the end characters of the range,
in ascending order, with a '<code>-</code>'.
All classes <code>%</code><em>x</em> described above can also be used as
components in <em>set</em>.
All other characters in <em>set</em> represent themselves.
For example, <code>[%w_]</code> (or <code>[_%w]</code>)
represents all alphanumeric characters plus the underscore,
<code>[0-7]</code> represents the octal digits,
and <code>[0-7%l%-]</code> represents the octal digits plus
the lowercase letters plus the '<code>-</code>' character.


<p>
The interaction between ranges and classes is not defined.
Therefore, patterns like <code>[%a-z]</code> or <code>[a-%%]</code>
have no meaning.
</li>

<li><b><code>[^<em>set</em>]</code>: </b>
represents the complement of <em>set</em>,
where <em>set</em> is interpreted as above.
</li>

</ul><p>
For all classes represented by single letters (<code>%a</code>, <code>%c</code>, etc.),
the corresponding uppercase letter represents the complement of the class.
For instance, <code>%S</code> represents all non-space characters.


<p>
The definitions of letter, space, and other character groups
depend on the current locale.
In particular, the class <code>[a-z]</code> may not be equivalent to <code>%l</code>.





<h4>Pattern Item:</h4><p>
A <em>pattern item</em> can be

<ul>

<li>
a single character class,
which matches any single character in the class;
</li>

<li>
a single character class followed by '<code>*</code>',
which matches zero or more repetitions of characters in the class.
These repetition items will always match the longest possible sequence;
</li>

<li>
a single character class followed by '<code>+</code>',
which matches one or more repetitions of characters in the class.
These repetition items will always match the longest possible sequence;
</li>

<li>
a single character class followed by '<code>-</code>',
which also matches zero or more repetitions of characters in the class.
Unlike '<code>*</code>',
these repetition items will always match the shortest possible sequence;
</li>

<li>
a single character class followed by '<code>?</code>',
which matches zero or one occurrence of a character in the class.
It always matches one occurrence if possible;
</li>

<li>
<code>%<em>n</em></code>, for <em>n</em> between 1 and 9;
such item matches a substring equal to the <em>n</em>-th captured string
(see below);
</li>

<li>
<code>%b<em>xy</em></code>, where <em>x</em> and <em>y</em> are two distinct characters;
such item matches strings that start with&nbsp;<em>x</em>, end with&nbsp;<em>y</em>,
and where the <em>x</em> and <em>y</em> are <em>balanced</em>.
This means that, if one reads the string from left to right,
counting <em>+1</em> for an <em>x</em> and <em>-1</em> for a <em>y</em>,
the ending <em>y</em> is the first <em>y</em> where the count reaches 0.
For instance, the item <code>%b()</code> matches expressions with
balanced parentheses.
</li>

<li>
<code>%f[<em>set</em>]</code>, a <em>frontier pattern</em>;
such item matches an empty string at any position such that
the next character belongs to <em>set</em>
and the previous character does not belong to <em>set</em>.
The set <em>set</em> is interpreted as previously described.
The beginning and the end of the subject are handled as if
they were the character '<code>\0</code>'.
</li>

</ul>




<h4>Pattern:</h4><p>
A <em>pattern</em> is a sequence of pattern items.
A caret '<code>^</code>' at the beginning of a pattern anchors the match at the
beginning of the subject string.
A '<code>$</code>' at the end of a pattern anchors the match at the
end of the subject string.
At other positions,
'<code>^</code>' and '<code>$</code>' have no special meaning and represent themselves.





<h4>Captures:</h4><p>
A pattern can contain sub-patterns enclosed in parentheses;
they describe <em>captures</em>.
When a match succeeds, the substrings of the subject string
that match captures are stored (<em>captured</em>) for future use.
Captures are numbered according to their left parentheses.
For instance, in the pattern <code>"(a*(.)%w(%s*))"</code>,
the part of the string matching <code>"a*(.)%w(%s*)"</code> is
stored as the first capture (and therefore has number&nbsp;1);
the character matching "<code>.</code>" is captured with number&nbsp;2,
and the part matching "<code>%s*</code>" has number&nbsp;3.


<p>
As a special case, the empty capture <code>()</code> captures
the current string position (a number).
For instance, if we apply the pattern <code>"()aa()"</code> on the
string <code>"flaaap"</code>, there will be two captures: 3&nbsp;and&nbsp;5.







<h3>6.4.2 &ndash; <a name="6.4.2">Format Strings for Pack and Unpack</a></h3>

<p>
The first argument to <a href="#pdf-string.pack"><code>string.pack</code></a>,
<a href="#pdf-string.packsize"><code>string.packsize</code></a>, and <a href="#pdf-string.unpack"><code>string.unpack</code></a>
is a format string,
which describes the layout of the structure being created or read.


<p>
A format string is a sequence of conversion options.
The conversion options are as follows:

<ul>
<li><b><code>&lt;</code>: </b>sets little endian</li>
<li><b><code>&gt;</code>: </b>sets big endian</li>
<li><b><code>=</code>: </b>sets native endian</li>
<li><b><code>![<em>n</em>]</code>: </b>sets maximum alignment to <code>n</code>
(default is native alignment)</li>
<li><b><code>b</code>: </b>a signed byte (<code>char</code>)</li>
<li><b><code>B</code>: </b>an unsigned byte (<code>char</code>)</li>
<li><b><code>h</code>: </b>a signed <code>short</code> (native size)</li>
<li><b><code>H</code>: </b>an unsigned <code>short</code> (native size)</li>
<li><b><code>l</code>: </b>a signed <code>long</code> (native size)</li>
<li><b><code>L</code>: </b>an unsigned <code>long</code> (native size)</li>
<li><b><code>j</code>: </b>a <code>lua_Integer</code></li>
<li><b><code>J</code>: </b>a <code>lua_Unsigned</code></li>
<li><b><code>T</code>: </b>a <code>size_t</code> (native size)</li>
<li><b><code>i[<em>n</em>]</code>: </b>a signed <code>int</code> with <code>n</code> bytes
(default is native size)</li>
<li><b><code>I[<em>n</em>]</code>: </b>an unsigned <code>int</code> with <code>n</code> bytes
(default is native size)</li>
<li><b><code>f</code>: </b>a <code>float</code> (native size)</li>
<li><b><code>d</code>: </b>a <code>double</code> (native size)</li>
<li><b><code>n</code>: </b>a <code>lua_Number</code></li>
<li><b><code>c<em>n</em></code>: </b>a fixed-sized string with <code>n</code> bytes</li>
<li><b><code>z</code>: </b>a zero-terminated string</li>
<li><b><code>s[<em>n</em>]</code>: </b>a string preceded by its length
coded as an unsigned integer with <code>n</code> bytes
(default is a <code>size_t</code>)</li>
<li><b><code>x</code>: </b>one byte of padding</li>
<li><b><code>X<em>op</em></code>: </b>an empty item that aligns
according to option <code>op</code>
(which is otherwise ignored)</li>
<li><b>'<code> </code>': </b>(empty space) ignored</li>
</ul><p>
(A "<code>[<em>n</em>]</code>" means an optional integral numeral.)
Except for padding, spaces, and configurations
(options "<code>xX &lt;=&gt;!</code>"),
each option corresponds to an argument (in <a href="#pdf-string.pack"><code>string.pack</code></a>)
or a result (in <a href="#pdf-string.unpack"><code>string.unpack</code></a>).


<p>
For options "<code>!<em>n</em></code>", "<code>s<em>n</em></code>", "<code>i<em>n</em></code>", and "<code>I<em>n</em></code>",
<code>n</code> can be any integer between 1 and 16.
All integral options check overflows;
<a href="#pdf-string.pack"><code>string.pack</code></a> checks whether the given value fits in the given size;
<a href="#pdf-string.unpack"><code>string.unpack</code></a> checks whether the read value fits in a Lua integer.


<p>
Any format string starts as if prefixed by "<code>!1=</code>",
that is,
with maximum alignment of 1 (no alignment)
and native endianness.


<p>
Alignment works as follows:
For each option,
the format gets extra padding until the data starts
at an offset that is a multiple of the minimum between the
option size and the maximum alignment;
this minimum must be a power of 2.
Options "<code>c</code>" and "<code>z</code>" are not aligned;
option "<code>s</code>" follows the alignment of its starting integer.


<p>
All padding is filled with zeros by <a href="#pdf-string.pack"><code>string.pack</code></a>
(and ignored by <a href="#pdf-string.unpack"><code>string.unpack</code></a>).







<h2>6.5 &ndash; <a name="6.5">UTF-8 Support</a></h2>

<p>
This library provides basic support for UTF-8 encoding.
It provides all its functions inside the table <a name="pdf-utf8"><code>utf8</code></a>.
This library does not provide any support for Unicode other
than the handling of the encoding.
Any operation that needs the meaning of a character,
such as character classification, is outside its scope.


<p>
Unless stated otherwise,
all functions that expect a byte position as a parameter
assume that the given position is either the start of a byte sequence
or one plus the length of the subject string.
As in the string library,
negative indices count from the end of the string.


<p>
<hr><h3><a name="pdf-utf8.char"><code>utf8.char (&middot;&middot;&middot;)</code></a></h3>
Receives zero or more integers,
converts each one to its corresponding UTF-8 byte sequence
and returns a string with the concatenation of all these sequences.




<p>
<hr><h3><a name="pdf-utf8.charpattern"><code>utf8.charpattern</code></a></h3>
The pattern (a string, not a function) "<code>[\0-\x7F\xC2-\xF4][\x80-\xBF]*</code>"
(see <a href="#6.4.1">&sect;6.4.1</a>),
which matches exactly one UTF-8 byte sequence,
assuming that the subject is a valid UTF-8 string.




<p>
<hr><h3><a name="pdf-utf8.codes"><code>utf8.codes (s)</code></a></h3>


<p>
Returns values so that the construction

<pre>
     for p, c in utf8.codes(s) do <em>body</em> end
</pre><p>
will iterate over all characters in string <code>s</code>,
with <code>p</code> being the position (in bytes) and <code>c</code> the code point
of each character.
It raises an error if it meets any invalid byte sequence.




<p>
<hr><h3><a name="pdf-utf8.codepoint"><code>utf8.codepoint (s [, i [, j]])</code></a></h3>
Returns the codepoints (as integers) from all characters in <code>s</code>
that start between byte position <code>i</code> and <code>j</code> (both included).
The default for <code>i</code> is 1 and for <code>j</code> is <code>i</code>.
It raises an error if it meets any invalid byte sequence.




<p>
<hr><h3><a name="pdf-utf8.len"><code>utf8.len (s [, i [, j]])</code></a></h3>
Returns the number of UTF-8 characters in string <code>s</code>
that start between positions <code>i</code> and <code>j</code> (both inclusive).
The default for <code>i</code> is 1 and for <code>j</code> is -1.
If it finds any invalid byte sequence,
returns a false value plus the position of the first invalid byte. 




<p>
<hr><h3><a name="pdf-utf8.offset"><code>utf8.offset (s, n [, i])</code></a></h3>
Returns the position (in bytes) where the encoding of the
<code>n</code>-th character of <code>s</code>
(counting from position <code>i</code>) starts.
A negative <code>n</code> gets characters before position <code>i</code>.
The default for <code>i</code> is 1 when <code>n</code> is non-negative
and <code>#s + 1</code> otherwise,
so that <code>utf8.offset(s, -n)</code> gets the offset of the
<code>n</code>-th character from the end of the string.
If the specified character is neither in the subject
nor right after its end,
the function returns <b>nil</b>.


<p>
As a special case,
when <code>n</code> is 0 the function returns the start of the encoding
of the character that contains the <code>i</code>-th byte of <code>s</code>.


<p>
This function assumes that <code>s</code> is a valid UTF-8 string.







<h2>6.6 &ndash; <a name="6.6">Table Manipulation</a></h2>

<p>
This library provides generic functions for table manipulation.
It provides all its functions inside the table <a name="pdf-table"><code>table</code></a>.


<p>
Remember that, whenever an operation needs the length of a table,
the table must be a proper sequence
or have a <code>__len</code> metamethod (see <a href="#3.4.7">&sect;3.4.7</a>).
All functions ignore non-numeric keys
in the tables given as arguments.


<p>
<hr><h3><a name="pdf-table.concat"><code>table.concat (list [, sep [, i [, j]]])</code></a></h3>


<p>
Given a list where all elements are strings or numbers,
returns the string <code>list[i]..sep..list[i+1] &middot;&middot;&middot; sep..list[j]</code>.
The default value for <code>sep</code> is the empty string,
the default for <code>i</code> is 1,
and the default for <code>j</code> is <code>#list</code>.
If <code>i</code> is greater than <code>j</code>, returns the empty string.




<p>
<hr><h3><a name="pdf-table.insert"><code>table.insert (list, [pos,] value)</code></a></h3>


<p>
Inserts element <code>value</code> at position <code>pos</code> in <code>list</code>,
shifting up the elements
<code>list[pos], list[pos+1], &middot;&middot;&middot;, list[#list]</code>.
The default value for <code>pos</code> is <code>#list+1</code>,
so that a call <code>table.insert(t,x)</code> inserts <code>x</code> at the end
of list <code>t</code>.




<p>
<hr><h3><a name="pdf-table.move"><code>table.move (a1, f, e, t [,a2])</code></a></h3>


<p>
Moves elements from table <code>a1</code> to table <code>a2</code>.
This function performs the equivalent to the following
multiple assignment:
<code>a2[t],&middot;&middot;&middot; = a1[f],&middot;&middot;&middot;,a1[e]</code>.
The default for <code>a2</code> is <code>a1</code>.
The destination range can overlap with the source range.
Index <code>f</code> must be positive.




<p>
<hr><h3><a name="pdf-table.pack"><code>table.pack (&middot;&middot;&middot;)</code></a></h3>


<p>
Returns a new table with all parameters stored into keys 1, 2, etc.
and with a field "<code>n</code>" with the total number of parameters.
Note that the resulting table may not be a sequence.




<p>
<hr><h3><a name="pdf-table.remove"><code>table.remove (list [, pos])</code></a></h3>


<p>
Removes from <code>list</code> the element at position <code>pos</code>,
returning the value of the removed element.
When <code>pos</code> is an integer between 1 and <code>#list</code>,
it shifts down the elements
<code>list[pos+1], list[pos+2], &middot;&middot;&middot;, list[#list]</code>
and erases element <code>list[#list]</code>;
The index <code>pos</code> can also be 0 when <code>#list</code> is 0,
or <code>#list + 1</code>;
in those cases, the function erases the element <code>list[pos]</code>.


<p>
The default value for <code>pos</code> is <code>#list</code>,
so that a call <code>table.remove(l)</code> removes the last element
of list <code>l</code>.




<p>
<hr><h3><a name="pdf-table.sort"><code>table.sort (list [, comp])</code></a></h3>


<p>
Sorts list elements in a given order, <em>in-place</em>,
from <code>list[1]</code> to <code>list[#list]</code>.
If <code>comp</code> is given,
then it must be a function that receives two list elements
and returns true when the first element must come
before the second in the final order
(so that <code>not comp(list[i+1],list[i])</code> will be true after the sort).
If <code>comp</code> is not given,
then the standard Lua operator <code>&lt;</code> is used instead.


<p>
The sort algorithm is not stable;
that is, elements considered equal by the given order
may have their relative positions changed by the sort.




<p>
<hr><h3><a name="pdf-table.unpack"><code>table.unpack (list [, i [, j]])</code></a></h3>


<p>
Returns the elements from the given list.
This function is equivalent to

<pre>
     return list[i], list[i+1], &middot;&middot;&middot;, list[j]
</pre><p>
By default, <code>i</code> is&nbsp;1 and <code>j</code> is <code>#list</code>.







<h2>6.7 &ndash; <a name="6.7">Mathematical Functions</a></h2>

<p>
This library provides basic mathematical functions.
It provides all its functions and constants inside the table <a name="pdf-math"><code>math</code></a>.
Functions with the annotation "<code>integer/float</code>" give
integer results for integer arguments
and float results for float (or mixed) arguments.
Rounding functions
(<a href="#pdf-math.ceil"><code>math.ceil</code></a>, <a href="#pdf-math.floor"><code>math.floor</code></a>, and <a href="#pdf-math.modf"><code>math.modf</code></a>)
return an integer when the result fits in the range of an integer,
or a float otherwise.


<p>
<hr><h3><a name="pdf-math.abs"><code>math.abs (x)</code></a></h3>


<p>
Returns the absolute value of <code>x</code>. (integer/float)




<p>
<hr><h3><a name="pdf-math.acos"><code>math.acos (x)</code></a></h3>


<p>
Returns the arc cosine of <code>x</code> (in radians).




<p>
<hr><h3><a name="pdf-math.asin"><code>math.asin (x)</code></a></h3>


<p>
Returns the arc sine of <code>x</code> (in radians).




<p>
<hr><h3><a name="pdf-math.atan"><code>math.atan (y [, x])</code></a></h3>


<p>

Returns the arc tangent of <code>y/x</code> (in radians),
but uses the signs of both parameters to find the
quadrant of the result.
(It also handles correctly the case of <code>x</code> being zero.)


<p>
The default value for <code>x</code> is 1,
so that the call <code>math.atan(y)</code>
returns the arc tangent of <code>y</code>.




<p>
<hr><h3><a name="pdf-math.ceil"><code>math.ceil (x)</code></a></h3>


<p>
Returns the smallest integral value larger than or equal to <code>x</code>.




<p>
<hr><h3><a name="pdf-math.cos"><code>math.cos (x)</code></a></h3>


<p>
Returns the cosine of <code>x</code> (assumed to be in radians).




<p>
<hr><h3><a name="pdf-math.deg"><code>math.deg (x)</code></a></h3>


<p>
Converts the angle <code>x</code> from radians to degrees.




<p>
<hr><h3><a name="pdf-math.exp"><code>math.exp (x)</code></a></h3>


<p>
Returns the value <em>e<sup>x</sup></em>
(where <code>e</code> is the base of natural logarithms).




<p>
<hr><h3><a name="pdf-math.floor"><code>math.floor (x)</code></a></h3>


<p>
Returns the largest integral value smaller than or equal to <code>x</code>.




<p>
<hr><h3><a name="pdf-math.fmod"><code>math.fmod (x, y)</code></a></h3>


<p>
Returns the remainder of the division of <code>x</code> by <code>y</code>
that rounds the quotient towards zero. (integer/float)




<p>
<hr><h3><a name="pdf-math.huge"><code>math.huge</code></a></h3>


<p>
The float value <code>HUGE_VAL</code>,
a value larger than any other numerical value.




<p>
<hr><h3><a name="pdf-math.log"><code>math.log (x [, base])</code></a></h3>


<p>
Returns the logarithm of <code>x</code> in the given base.
The default for <code>base</code> is <em>e</em>
(so that the function returns the natural logarithm of <code>x</code>).




<p>
<hr><h3><a name="pdf-math.max"><code>math.max (x, &middot;&middot;&middot;)</code></a></h3>


<p>
Returns the argument with the maximum value,
according to the Lua operator <code>&lt;</code>. (integer/float)




<p>
<hr><h3><a name="pdf-math.maxinteger"><code>math.maxinteger</code></a></h3>
An integer with the maximum value for an integer.




<p>
<hr><h3><a name="pdf-math.min"><code>math.min (x, &middot;&middot;&middot;)</code></a></h3>


<p>
Returns the argument with the minimum value,
according to the Lua operator <code>&lt;</code>. (integer/float)




<p>
<hr><h3><a name="pdf-math.mininteger"><code>math.mininteger</code></a></h3>
An integer with the minimum value for an integer.




<p>
<hr><h3><a name="pdf-math.modf"><code>math.modf (x)</code></a></h3>


<p>
Returns the integral part of <code>x</code> and the fractional part of <code>x</code>.
Its second result is always a float.




<p>
<hr><h3><a name="pdf-math.pi"><code>math.pi</code></a></h3>


<p>
The value of <em>&pi;</em>.




<p>
<hr><h3><a name="pdf-math.rad"><code>math.rad (x)</code></a></h3>


<p>
Converts the angle <code>x</code> from degrees to radians.




<p>
<hr><h3><a name="pdf-math.random"><code>math.random ([m [, n]])</code></a></h3>


<p>
When called without arguments,
returns a pseudo-random float with uniform distribution
in the range  <em>[0,1)</em>.  
When called with two integers <code>m</code> and <code>n</code>,
<code>math.random</code> returns a pseudo-random integer
with uniform distribution in the range <em>[m, n]</em>.
(The value <em>m-n</em> cannot be negative and must fit in a Lua integer.)
The call <code>math.random(n)</code> is equivalent to <code>math.random(1,n)</code>.


<p>
This function is an interface to the underling
pseudo-random generator function provided by C.
No guarantees can be given for its statistical properties.




<p>
<hr><h3><a name="pdf-math.randomseed"><code>math.randomseed (x)</code></a></h3>


<p>
Sets <code>x</code> as the "seed"
for the pseudo-random generator:
equal seeds produce equal sequences of numbers.




<p>
<hr><h3><a name="pdf-math.sin"><code>math.sin (x)</code></a></h3>


<p>
Returns the sine of <code>x</code> (assumed to be in radians).




<p>
<hr><h3><a name="pdf-math.sqrt"><code>math.sqrt (x)</code></a></h3>


<p>
Returns the square root of <code>x</code>.
(You can also use the expression <code>x^0.5</code> to compute this value.)




<p>
<hr><h3><a name="pdf-math.tan"><code>math.tan (x)</code></a></h3>


<p>
Returns the tangent of <code>x</code> (assumed to be in radians).




<p>
<hr><h3><a name="pdf-math.tointeger"><code>math.tointeger (x)</code></a></h3>


<p>
If the value <code>x</code> is convertible to an integer,
returns that integer.
Otherwise, returns <b>nil</b>.




<p>
<hr><h3><a name="pdf-math.type"><code>math.type (x)</code></a></h3>


<p>
Returns "<code>integer</code>" if <code>x</code> is an integer,
"<code>float</code>" if it is a float,
or <b>nil</b> if <code>x</code> is not a number.




<p>
<hr><h3><a name="pdf-math.ult"><code>math.ult (m, n)</code></a></h3>


<p>
Returns a boolean,
true if integer <code>m</code> is below integer <code>n</code> when
they are compared as unsigned integers.







<h2>6.8 &ndash; <a name="6.8">Input and Output Facilities</a></h2>

<p>
The I/O library provides two different styles for file manipulation.
The first one uses implicit file handles;
that is, there are operations to set a default input file and a
default output file,
and all input/output operations are over these default files.
The second style uses explicit file handles.


<p>
When using implicit file handles,
all operations are supplied by table <a name="pdf-io"><code>io</code></a>.
When using explicit file handles,
the operation <a href="#pdf-io.open"><code>io.open</code></a> returns a file handle
and then all operations are supplied as methods of the file handle.


<p>
The table <code>io</code> also provides
three predefined file handles with their usual meanings from C:
<a name="pdf-io.stdin"><code>io.stdin</code></a>, <a name="pdf-io.stdout"><code>io.stdout</code></a>, and <a name="pdf-io.stderr"><code>io.stderr</code></a>.
The I/O library never closes these files.


<p>
Unless otherwise stated,
all I/O functions return <b>nil</b> on failure
(plus an error message as a second result and
a system-dependent error code as a third result)
and some value different from <b>nil</b> on success.
On non-POSIX systems,
the computation of the error message and error code
in case of errors
may be not thread safe,
because they rely on the global C variable <code>errno</code>.


<p>
<hr><h3><a name="pdf-io.close"><code>io.close ([file])</code></a></h3>


<p>
Equivalent to <code>file:close()</code>.
Without a <code>file</code>, closes the default output file.




<p>
<hr><h3><a name="pdf-io.flush"><code>io.flush ()</code></a></h3>


<p>
Equivalent to <code>io.output():flush()</code>.




<p>
<hr><h3><a name="pdf-io.input"><code>io.input ([file])</code></a></h3>


<p>
When called with a file name, it opens the named file (in text mode),
and sets its handle as the default input file.
When called with a file handle,
it simply sets this file handle as the default input file.
When called without parameters,
it returns the current default input file.


<p>
In case of errors this function raises the error,
instead of returning an error code.




<p>
<hr><h3><a name="pdf-io.lines"><code>io.lines ([filename &middot;&middot;&middot;])</code></a></h3>


<p>
Opens the given file name in read mode
and returns an iterator function that
works like <code>file:lines(&middot;&middot;&middot;)</code> over the opened file.
When the iterator function detects the end of file,
it returns no values (to finish the loop) and automatically closes the file.


<p>
The call <code>io.lines()</code> (with no file name) is equivalent
to <code>io.input():lines("*l")</code>;
that is, it iterates over the lines of the default input file.
In this case it does not close the file when the loop ends.


<p>
In case of errors this function raises the error,
instead of returning an error code.




<p>
<hr><h3><a name="pdf-io.open"><code>io.open (filename [, mode])</code></a></h3>


<p>
This function opens a file,
in the mode specified in the string <code>mode</code>.
It returns a new file handle,
or, in case of errors, <b>nil</b> plus an error message.


<p>
The <code>mode</code> string can be any of the following:

<ul>
<li><b>"<code>r</code>": </b> read mode (the default);</li>
<li><b>"<code>w</code>": </b> write mode;</li>
<li><b>"<code>a</code>": </b> append mode;</li>
<li><b>"<code>r+</code>": </b> update mode, all previous data is preserved;</li>
<li><b>"<code>w+</code>": </b> update mode, all previous data is erased;</li>
<li><b>"<code>a+</code>": </b> append update mode, previous data is preserved,
  writing is only allowed at the end of file.</li>
</ul><p>
The <code>mode</code> string can also have a '<code>b</code>' at the end,
which is needed in some systems to open the file in binary mode.




<p>
<hr><h3><a name="pdf-io.output"><code>io.output ([file])</code></a></h3>


<p>
Similar to <a href="#pdf-io.input"><code>io.input</code></a>, but operates over the default output file.




<p>
<hr><h3><a name="pdf-io.popen"><code>io.popen (prog [, mode])</code></a></h3>


<p>
This function is system dependent and is not available
on all platforms.


<p>
Starts program <code>prog</code> in a separated process and returns
a file handle that you can use to read data from this program
(if <code>mode</code> is <code>"r"</code>, the default)
or to write data to this program
(if <code>mode</code> is <code>"w"</code>).




<p>
<hr><h3><a name="pdf-io.read"><code>io.read (&middot;&middot;&middot;)</code></a></h3>


<p>
Equivalent to <code>io.input():read(&middot;&middot;&middot;)</code>.




<p>
<hr><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()</code></a></h3>


<p>
Returns a handle for a temporary file.
This file is opened in update mode
and it is automatically removed when the program ends.




<p>
<hr><h3><a name="pdf-io.type"><code>io.type (obj)</code></a></h3>


<p>
Checks whether <code>obj</code> is a valid file handle.
Returns the string <code>"file"</code> if <code>obj</code> is an open file handle,
<code>"closed file"</code> if <code>obj</code> is a closed file handle,
or <b>nil</b> if <code>obj</code> is not a file handle.




<p>
<hr><h3><a name="pdf-io.write"><code>io.write (&middot;&middot;&middot;)</code></a></h3>


<p>
Equivalent to <code>io.output():write(&middot;&middot;&middot;)</code>.




<p>
<hr><h3><a name="pdf-file:close"><code>file:close ()</code></a></h3>


<p>
Closes <code>file</code>.
Note that files are automatically closed when
their handles are garbage collected,
but that takes an unpredictable amount of time to happen.


<p>
When closing a file handle created with <a href="#pdf-io.popen"><code>io.popen</code></a>,
<a href="#pdf-file:close"><code>file:close</code></a> returns the same values
returned by <a href="#pdf-os.execute"><code>os.execute</code></a>.




<p>
<hr><h3><a name="pdf-file:flush"><code>file:flush ()</code></a></h3>


<p>
Saves any written data to <code>file</code>.




<p>
<hr><h3><a name="pdf-file:lines"><code>file:lines (&middot;&middot;&middot;)</code></a></h3>


<p>
Returns an iterator function that,
each time it is called,
reads the file according to the given formats.
When no format is given,
uses "<code>l</code>" as a default.
As an example, the construction

<pre>
     for c in file:lines(1) do <em>body</em> end
</pre><p>
will iterate over all characters of the file,
starting at the current position.
Unlike <a href="#pdf-io.lines"><code>io.lines</code></a>, this function does not close the file
when the loop ends.


<p>
In case of errors this function raises the error,
instead of returning an error code.




<p>
<hr><h3><a name="pdf-file:read"><code>file:read (&middot;&middot;&middot;)</code></a></h3>


<p>
Reads the file <code>file</code>,
according to the given formats, which specify what to read.
For each format,
the function returns a string or a number with the characters read,
or <b>nil</b> if it cannot read data with the specified format.
(In this latter case,
the function does not read subsequent formats.)
When called without formats,
it uses a default format that reads the next line
(see below).


<p>
The available formats are

<ul>

<li><b>"<code>n</code>": </b>
reads a numeral and returns it as a float or an integer,
following the lexical conventions of Lua.
(The numeral may have leading spaces and a sign.)
This format always reads the longest input sequence that
is a valid prefix for a number;
if that prefix does not form a valid number
(e.g., an empty string, "<code>0x</code>", or "<code>3.4e-</code>"),
it is discarded and the function returns <b>nil</b>.
</li>

<li><b>"<code>i</code>": </b>
reads an integral number and returns it as an integer.
</li>

<li><b>"<code>a</code>": </b>
reads the whole file, starting at the current position.
On end of file, it returns the empty string.
</li>

<li><b>"<code>l</code>": </b>
reads the next line skipping the end of line,
returning <b>nil</b> on end of file.
This is the default format.
</li>

<li><b>"<code>L</code>": </b>
reads the next line keeping the end-of-line character (if present),
returning <b>nil</b> on end of file.
</li>

<li><b><em>number</em>: </b>
reads a string with up to this number of bytes,
returning <b>nil</b> on end of file.
If <code>number</code> is zero,
it reads nothing and returns an empty string,
or <b>nil</b> on end of file.
</li>

</ul><p>
The formats "<code>l</code>" and "<code>L</code>" should be used only for text files.




<p>
<hr><h3><a name="pdf-file:seek"><code>file:seek ([whence [, offset]])</code></a></h3>


<p>
Sets and gets the file position,
measured from the beginning of the file,
to the position given by <code>offset</code> plus a base
specified by the string <code>whence</code>, as follows:

<ul>
<li><b>"<code>set</code>": </b> base is position 0 (beginning of the file);</li>
<li><b>"<code>cur</code>": </b> base is current position;</li>
<li><b>"<code>end</code>": </b> base is end of file;</li>
</ul><p>
In case of success, <code>seek</code> returns the final file position,
measured in bytes from the beginning of the file.
If <code>seek</code> fails, it returns <b>nil</b>,
plus a string describing the error.


<p>
The default value for <code>whence</code> is <code>"cur"</code>,
and for <code>offset</code> is 0.
Therefore, the call <code>file:seek()</code> returns the current
file position, without changing it;
the call <code>file:seek("set")</code> sets the position to the
beginning of the file (and returns 0);
and the call <code>file:seek("end")</code> sets the position to the
end of the file, and returns its size.




<p>
<hr><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (mode [, size])</code></a></h3>


<p>
Sets the buffering mode for an output file.
There are three available modes:

<ul>

<li><b>"<code>no</code>": </b>
no buffering; the result of any output operation appears immediately.
</li>

<li><b>"<code>full</code>": </b>
full buffering; output operation is performed only
when the buffer is full or when
you explicitly <code>flush</code> the file (see <a href="#pdf-io.flush"><code>io.flush</code></a>).
</li>

<li><b>"<code>line</code>": </b>
line buffering; output is buffered until a newline is output
or there is any input from some special files
(such as a terminal device).
</li>

</ul><p>
For the last two cases, <code>size</code>
specifies the size of the buffer, in bytes.
The default is an appropriate size.




<p>
<hr><h3><a name="pdf-file:write"><code>file:write (&middot;&middot;&middot;)</code></a></h3>


<p>
Writes the value of each of its arguments to <code>file</code>.
The arguments must be strings or numbers.


<p>
In case of success, this function returns <code>file</code>.
Otherwise it returns <b>nil</b> plus a string describing the error.







<h2>6.9 &ndash; <a name="6.9">Operating System Facilities</a></h2>

<p>
This library is implemented through table <a name="pdf-os"><code>os</code></a>.


<p>
<hr><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3>


<p>
Returns an approximation of the amount in seconds of CPU time
used by the program.




<p>
<hr><h3><a name="pdf-os.date"><code>os.date ([format [, time]])</code></a></h3>


<p>
Returns a string or a table containing date and time,
formatted according to the given string <code>format</code>.


<p>
If the <code>time</code> argument is present,
this is the time to be formatted
(see the <a href="#pdf-os.time"><code>os.time</code></a> function for a description of this value).
Otherwise, <code>date</code> formats the current time.


<p>
If <code>format</code> starts with '<code>!</code>',
then the date is formatted in Coordinated Universal Time.
After this optional character,
if <code>format</code> is the string "<code>*t</code>",
then <code>date</code> returns a table with the following fields:
<code>year</code> (four digits), <code>month</code> (1&ndash;12), <code>day</code> (1&ndash;31),
<code>hour</code> (0&ndash;23), <code>min</code> (0&ndash;59), <code>sec</code> (0&ndash;61),
<code>wday</code> (weekday, Sunday is&nbsp;1),
<code>yday</code> (day of the year),
and <code>isdst</code> (daylight saving flag, a boolean).
This last field may be absent
if the information is not available.


<p>
If <code>format</code> is not "<code>*t</code>",
then <code>date</code> returns the date as a string,
formatted according to the same rules as the ISO&nbsp;C function <code>strftime</code>.


<p>
When called without arguments,
<code>date</code> returns a reasonable date and time representation that depends on
the host system and on the current locale
(that is, <code>os.date()</code> is equivalent to <code>os.date("%c")</code>).


<p>
On non-POSIX systems,
this function may be not thread safe
because of its reliance on C&nbsp;function <code>gmtime</code> and C&nbsp;function <code>localtime</code>.




<p>
<hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3>


<p>
Returns the difference, in seconds,
from time <code>t1</code> to time <code>t2</code>
(where the times are values returned by <a href="#pdf-os.time"><code>os.time</code></a>).
In POSIX, Windows, and some other systems,
this value is exactly <code>t2</code><em>-</em><code>t1</code>.




<p>
<hr><h3><a name="pdf-os.execute"><code>os.execute ([command])</code></a></h3>


<p>
This function is equivalent to the ISO&nbsp;C function <code>system</code>.
It passes <code>command</code> to be executed by an operating system shell.
Its first result is <b>true</b>
if the command terminated successfully,
or <b>nil</b> otherwise.
After this first result
the function returns a string plus a number,
as follows:

<ul>

<li><b>"<code>exit</code>": </b>
the command terminated normally;
the following number is the exit status of the command.
</li>

<li><b>"<code>signal</code>": </b>
the command was terminated by a signal;
the following number is the signal that terminated the command.
</li>

</ul>

<p>
When called without a <code>command</code>,
<code>os.execute</code> returns a boolean that is true if a shell is available.




<p>
<hr><h3><a name="pdf-os.exit"><code>os.exit ([code [, close]])</code></a></h3>


<p>
Calls the ISO&nbsp;C function <code>exit</code> to terminate the host program.
If <code>code</code> is <b>true</b>,
the returned status is <code>EXIT_SUCCESS</code>;
if <code>code</code> is <b>false</b>,
the returned status is <code>EXIT_FAILURE</code>;
if <code>code</code> is a number,
the returned status is this number.
The default value for <code>code</code> is <b>true</b>.


<p>
If the optional second argument <code>close</code> is true,
closes the Lua state before exiting.




<p>
<hr><h3><a name="pdf-os.getenv"><code>os.getenv (varname)</code></a></h3>


<p>
Returns the value of the process environment variable <code>varname</code>,
or <b>nil</b> if the variable is not defined.




<p>
<hr><h3><a name="pdf-os.remove"><code>os.remove (filename)</code></a></h3>


<p>
Deletes the file (or empty directory, on POSIX systems)
with the given name.
If this function fails, it returns <b>nil</b>,
plus a string describing the error and the error code.




<p>
<hr><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)</code></a></h3>


<p>
Renames file or directory named <code>oldname</code> to <code>newname</code>.
If this function fails, it returns <b>nil</b>,
plus a string describing the error and the error code.




<p>
<hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])</code></a></h3>


<p>
Sets the current locale of the program.
<code>locale</code> is a system-dependent string specifying a locale;
<code>category</code> is an optional string describing which category to change:
<code>"all"</code>, <code>"collate"</code>, <code>"ctype"</code>,
<code>"monetary"</code>, <code>"numeric"</code>, or <code>"time"</code>;
the default category is <code>"all"</code>.
The function returns the name of the new locale,
or <b>nil</b> if the request cannot be honored.


<p>
If <code>locale</code> is the empty string,
the current locale is set to an implementation-defined native locale.
If <code>locale</code> is the string "<code>C</code>",
the current locale is set to the standard C locale.


<p>
When called with <b>nil</b> as the first argument,
this function only returns the name of the current locale
for the given category.


<p>
This function may be not thread safe
because of its reliance on C&nbsp;function <code>setlocale</code>.




<p>
<hr><h3><a name="pdf-os.time"><code>os.time ([table])</code></a></h3>


<p>
Returns the current time when called without arguments,
or a time representing the date and time specified by the given table.
This table must have fields <code>year</code>, <code>month</code>, and <code>day</code>,
and may have fields
<code>hour</code> (default is 12),
<code>min</code> (default is 0),
<code>sec</code> (default is 0),
and <code>isdst</code> (default is <b>nil</b>).
For a description of these fields, see the <a href="#pdf-os.date"><code>os.date</code></a> function.


<p>
The returned value is a number, whose meaning depends on your system.
In POSIX, Windows, and some other systems,
this number counts the number
of seconds since some given start time (the "epoch").
In other systems, the meaning is not specified,
and the number returned by <code>time</code> can be used only as an argument to
<a href="#pdf-os.date"><code>os.date</code></a> and <a href="#pdf-os.difftime"><code>os.difftime</code></a>.




<p>
<hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3>


<p>
Returns a string with a file name that can
be used for a temporary file.
The file must be explicitly opened before its use
and explicitly removed when no longer needed.


<p>
On POSIX systems,
this function also creates a file with that name,
to avoid security risks.
(Someone else might create the file with wrong permissions
in the time between getting the name and creating the file.)
You still have to open the file to use it
and to remove it (even if you do not use it).


<p>
When possible,
you may prefer to use <a href="#pdf-io.tmpfile"><code>io.tmpfile</code></a>,
which automatically removes the file when the program ends.







<h2>6.10 &ndash; <a name="6.10">The Debug Library</a></h2>

<p>
This library provides
the functionality of the debug interface (<a href="#4.9">&sect;4.9</a>) to Lua programs.
You should exert care when using this library.
Several of its functions
violate basic assumptions about Lua code
(e.g., that variables local to a function
cannot be accessed from outside;
that userdata metatables cannot be changed by Lua code;
that Lua programs do not crash)
and therefore can compromise otherwise secure code.
Moreover, some functions in this library may be slow.


<p>
All functions in this library are provided
inside the <a name="pdf-debug"><code>debug</code></a> table.
All functions that operate over a thread
have an optional first argument which is the
thread to operate over.
The default is always the current thread.


<p>
<hr><h3><a name="pdf-debug.debug"><code>debug.debug ()</code></a></h3>


<p>
Enters an interactive mode with the user,
running each string that the user enters.
Using simple commands and other debug facilities,
the user can inspect global and local variables,
change their values, evaluate expressions, and so on.
A line containing only the word <code>cont</code> finishes this function,
so that the caller continues its execution.


<p>
Note that commands for <code>debug.debug</code> are not lexically nested
within any function and so have no direct access to local variables.




<p>
<hr><h3><a name="pdf-debug.gethook"><code>debug.gethook ([thread])</code></a></h3>


<p>
Returns the current hook settings of the thread, as three values:
the current hook function, the current hook mask,
and the current hook count
(as set by the <a href="#pdf-debug.sethook"><code>debug.sethook</code></a> function).




<p>
<hr><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([thread,] f [, what])</code></a></h3>


<p>
Returns a table with information about a function.
You can give the function directly
or you can give a number as the value of <code>f</code>,
which means the function running at level <code>f</code> of the call stack
of the given thread:
level&nbsp;0 is the current function (<code>getinfo</code> itself);
level&nbsp;1 is the function that called <code>getinfo</code>
(except for tail calls, which do not count on the stack);
and so on.
If <code>f</code> is a number larger than the number of active functions,
then <code>getinfo</code> returns <b>nil</b>.


<p>
The returned table can contain all the fields returned by <a href="#lua_getinfo"><code>lua_getinfo</code></a>,
with the string <code>what</code> describing which fields to fill in.
The default for <code>what</code> is to get all information available,
except the table of valid lines.
If present,
the option '<code>f</code>'
adds a field named <code>func</code> with the function itself.
If present,
the option '<code>L</code>'
adds a field named <code>activelines</code> with the table of
valid lines.


<p>
For instance, the expression <code>debug.getinfo(1,"n").name</code> returns
a table with a name for the current function,
if a reasonable name can be found,
and the expression <code>debug.getinfo(print)</code>
returns a table with all available information
about the <a href="#pdf-print"><code>print</code></a> function.




<p>
<hr><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([thread,] f, local)</code></a></h3>


<p>
This function returns the name and the value of the local variable
with index <code>local</code> of the function at level <code>f</code> of the stack.
This function accesses not only explicit local variables,
but also parameters, temporaries, etc.


<p>
The first parameter or local variable has index&nbsp;1, and so on,
following the order that they are declared in the code,
counting only the variables that are active
in the current scope of the function.
Negative indices refer to vararg parameters;
-1 is the first vararg parameter.
The function returns <b>nil</b> if there is no variable with the given index,
and raises an error when called with a level out of range.
(You can call <a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a> to check whether the level is valid.)


<p>
Variable names starting with '<code>(</code>' (open parenthesis) 
represent variables with no known names
(internal variables such as loop control variables,
and variables from chunks saved without debug information).


<p>
The parameter <code>f</code> may also be a function.
In that case, <code>getlocal</code> returns only the name of function parameters.




<p>
<hr><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (value)</code></a></h3>


<p>
Returns the metatable of the given <code>value</code>
or <b>nil</b> if it does not have a metatable.




<p>
<hr><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()</code></a></h3>


<p>
Returns the registry table (see <a href="#4.5">&sect;4.5</a>).




<p>
<hr><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (f, up)</code></a></h3>


<p>
This function returns the name and the value of the upvalue
with index <code>up</code> of the function <code>f</code>.
The function returns <b>nil</b> if there is no upvalue with the given index.


<p>
Variable names starting with '<code>(</code>' (open parenthesis) 
represent variables with no known names
(variables from chunks saved without debug information).




<p>
<hr><h3><a name="pdf-debug.getuservalue"><code>debug.getuservalue (u)</code></a></h3>


<p>
Returns the Lua value associated to <code>u</code>.
If <code>u</code> is not a userdata,
returns <b>nil</b>.




<p>
<hr><h3><a name="pdf-debug.sethook"><code>debug.sethook ([thread,] hook, mask [, count])</code></a></h3>


<p>
Sets the given function as a hook.
The string <code>mask</code> and the number <code>count</code> describe
when the hook will be called.
The string mask may have any combination of the following characters,
with the given meaning:

<ul>
<li><b>'<code>c</code>': </b> the hook is called every time Lua calls a function;</li>
<li><b>'<code>r</code>': </b> the hook is called every time Lua returns from a function;</li>
<li><b>'<code>l</code>': </b> the hook is called every time Lua enters a new line of code.</li>
</ul><p>
Moreover,
with a <code>count</code> different from zero,
the hook is called also after every <code>count</code> instructions.


<p>
When called without arguments,
<a href="#pdf-debug.sethook"><code>debug.sethook</code></a> turns off the hook.


<p>
When the hook is called, its first parameter is a string
describing the event that has triggered its call:
<code>"call"</code> (or <code>"tail call"</code>),
<code>"return"</code>,
<code>"line"</code>, and <code>"count"</code>.
For line events,
the hook also gets the new line number as its second parameter.
Inside a hook,
you can call <code>getinfo</code> with level&nbsp;2 to get more information about
the running function
(level&nbsp;0 is the <code>getinfo</code> function,
and level&nbsp;1 is the hook function).




<p>
<hr><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([thread,] level, local, value)</code></a></h3>


<p>
This function assigns the value <code>value</code> to the local variable
with index <code>local</code> of the function at level <code>level</code> of the stack.
The function returns <b>nil</b> if there is no local
variable with the given index,
and raises an error when called with a <code>level</code> out of range.
(You can call <code>getinfo</code> to check whether the level is valid.)
Otherwise, it returns the name of the local variable.


<p>
See <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a> for more information about
variable indices and names.




<p>
<hr><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (value, table)</code></a></h3>


<p>
Sets the metatable for the given <code>value</code> to the given <code>table</code>
(which can be <b>nil</b>).
Returns <code>value</code>.




<p>
<hr><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (f, up, value)</code></a></h3>


<p>
This function assigns the value <code>value</code> to the upvalue
with index <code>up</code> of the function <code>f</code>.
The function returns <b>nil</b> if there is no upvalue
with the given index.
Otherwise, it returns the name of the upvalue.




<p>
<hr><h3><a name="pdf-debug.setuservalue"><code>debug.setuservalue (udata, value)</code></a></h3>


<p>
Sets the given <code>value</code> as
the Lua value associated to the given <code>udata</code>.
<code>udata</code> must be a full userdata.


<p>
Returns <code>udata</code>.




<p>
<hr><h3><a name="pdf-debug.traceback"><code>debug.traceback ([thread,] [message [, level]])</code></a></h3>


<p>
If <code>message</code> is present but is neither a string nor <b>nil</b>,
this function returns <code>message</code> without further processing.
Otherwise,
it returns a string with a traceback of the call stack.
The optional <code>message</code> string is appended
at the beginning of the traceback.
An optional <code>level</code> number tells at which level
to start the traceback
(default is 1, the function calling <code>traceback</code>).




<p>
<hr><h3><a name="pdf-debug.upvalueid"><code>debug.upvalueid (f, n)</code></a></h3>


<p>
Returns a unique identifier (as a light userdata)
for the upvalue numbered <code>n</code>
from the given function.


<p>
These unique identifiers allow a program to check whether different
closures share upvalues.
Lua closures that share an upvalue
(that is, that access a same external local variable)
will return identical ids for those upvalue indices.




<p>
<hr><h3><a name="pdf-debug.upvaluejoin"><code>debug.upvaluejoin (f1, n1, f2, n2)</code></a></h3>


<p>
Make the <code>n1</code>-th upvalue of the Lua closure <code>f1</code>
refer to the <code>n2</code>-th upvalue of the Lua closure <code>f2</code>.







<h1>7 &ndash; <a name="7">Lua Standalone</a></h1>

<p>
Although Lua has been designed as an extension language,
to be embedded in a host C&nbsp;program,
it is also frequently used as a standalone language.
An interpreter for Lua as a standalone language,
called simply <code>lua</code>,
is provided with the standard distribution.
The standalone interpreter includes
all standard libraries, including the debug library.
Its usage is:

<pre>
     lua [options] [script [args]]
</pre><p>
The options are:

<ul>
<li><b><code>-e <em>stat</em></code>: </b> executes string <em>stat</em>;</li>
<li><b><code>-l <em>mod</em></code>: </b> "requires" <em>mod</em>;</li>
<li><b><code>-i</code>: </b> enters interactive mode after running <em>script</em>;</li>
<li><b><code>-v</code>: </b> prints version information;</li>
<li><b><code>-E</code>: </b> ignores environment variables;</li>
<li><b><code>--</code>: </b> stops handling options;</li>
<li><b><code>-</code>: </b> executes <code>stdin</code> as a file and stops handling options.</li>
</ul><p>
After handling its options, <code>lua</code> runs the given <em>script</em>.
When called without arguments,
<code>lua</code> behaves as <code>lua -v -i</code>
when the standard input (<code>stdin</code>) is a terminal,
and as <code>lua -</code> otherwise.


<p>
When called without option <code>-E</code>, 
the interpreter checks for an environment variable <a name="pdf-LUA_INIT_5_3"><code>LUA_INIT_5_3</code></a>
(or <a name="pdf-LUA_INIT"><code>LUA_INIT</code></a> if the versioned name is not defined)
before running any argument.
If the variable content has the format <code>@<em>filename</em></code>,
then <code>lua</code> executes the file.
Otherwise, <code>lua</code> executes the string itself.


<p>
When called with option <code>-E</code>,
besides ignoring <code>LUA_INIT</code>,
Lua also ignores
the values of <code>LUA_PATH</code> and <code>LUA_CPATH</code>,
setting the values of
<a href="#pdf-package.path"><code>package.path</code></a> and <a href="#pdf-package.cpath"><code>package.cpath</code></a>
with the default paths defined in <code>luaconf.h</code>.


<p>
All options are handled in order, except <code>-i</code> and <code>-E</code>.
For instance, an invocation like

<pre>
     $ lua -e'a=1' -e 'print(a)' script.lua
</pre><p>
will first set <code>a</code> to 1, then print the value of <code>a</code>,
and finally run the file <code>script.lua</code> with no arguments.
(Here <code>$</code> is the shell prompt. Your prompt may be different.)


<p>
Before running any code,
<code>lua</code> collects all command-line arguments
in a global table called <code>arg</code>.
The script name goes to index 0,
the first argument after the script name goes to index 1,
and so on.
Any arguments before the script name
(that is, the interpreter name plus its options)
go to negative indices.
For instance, in the call

<pre>
     $ lua -la b.lua t1 t2
</pre><p>
the table is like this:

<pre>
     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }
</pre><p>
If there is no script in the call,
the interpreter name goes to index 0,
followed by the other arguments.
For instance, the call

<pre>
     $ lua -e "print(arg[1])"
</pre><p>
will print "<code>-e</code>".
If there is a script,
the script is called with parameters
<code>arg[1]</code>, &middot;&middot;&middot;, <code>arg[#arg]</code>.
(Like all chunks in Lua,
the script is compiled as a vararg function.)


<p>
In interactive mode,
Lua repeatedly prompts and waits for a line.
After reading a line,
Lua first try to interpret the line as an expression.
If it succeeds, it prints its value.
Otherwise, it interprets the line as a statement.
If you write an incomplete statement,
the interpreter waits for its completion
by issuing a different prompt.


<p>
In case of unprotected errors in the script,
the interpreter reports the error to the standard error stream.
If the error object is not a string but 
has a metamethod <code>__tostring</code>,
the interpreter calls this metamethod to produce the final message.
Otherwise, the interpreter converts the error object to a string
and adds a stack traceback to it.


<p>
When finishing normally,
the interpreter closes its main Lua state
(see <a href="#lua_close"><code>lua_close</code></a>).
The script can avoid this step by
calling <a href="#pdf-os.exit"><code>os.exit</code></a> to terminate.


<p>
To allow the use of Lua as a
script interpreter in Unix systems,
the standalone interpreter skips
the first line of a chunk if it starts with <code>#</code>.
Therefore, Lua scripts can be made into executable programs
by using <code>chmod +x</code> and the&nbsp;<code>#!</code> form,
as in

<pre>
     #!/usr/local/bin/lua
</pre><p>
(Of course,
the location of the Lua interpreter may be different in your machine.
If <code>lua</code> is in your <code>PATH</code>,
then

<pre>
     #!/usr/bin/env lua
</pre><p>
is a more portable solution.)



<h1>8 &ndash; <a name="8">Incompatibilities with the Previous Version</a></h1>

<p>
Here we list the incompatibilities that you may find when moving a program
from Lua&nbsp;5.2 to Lua&nbsp;5.3.
You can avoid some incompatibilities by compiling Lua with
appropriate options (see file <code>luaconf.h</code>).
However,
all these compatibility options will be removed in the future.


<p>
Lua versions can always change the C API in ways that
do not imply source-code changes in a program,
such as the numeric values for constants
or the implementation of functions as macros.
Therefore,
you should not assume that binaries are compatible between
different Lua versions.
Always recompile clients of the Lua API when
using a new version.


<p>
Similarly, Lua versions can always change the internal representation
of precompiled chunks;
precompiled chunks are not compatible between different Lua versions.


<p>
The standard paths in the official distribution may
change between versions.



<h2>8.1 &ndash; <a name="8.1">Changes in the Language</a></h2>
<ul>

<li>
The main difference between Lua&nbsp;5.2 and Lua&nbsp;5.3 is the
introduction of an integer subtype for numbers.
Although this change should not affect "normal" computations,
some computations
(mainly those that involve some kind of overflow)
can give different results.


<p>
You can fix these differences by forcing a number to be a float
(in Lua&nbsp;5.2 all numbers were float),
in particular writing constants with an ending <code>.0</code>
or using <code>x = x + 0.0</code> to convert a variable.
(This recommendation is only for a quick fix
for an occasional incompatibility;
it is not a general guideline for good programming.
For good programming,
use floats where you need floats
and integers where you need integers.)
</li>

<li>
The conversion of a float to a string now adds a <code>.0</code> suffix
to the result if it looks like an integer.
(For instance, the float 2.0 will be printed as <code>2.0</code>,
not as <code>2</code>.)
You should always use an explicit format
when you need a specific format for numbers.


<p>
(Formally this is not an incompatibility,
because Lua does not specify how numbers are formatted as strings,
but some programs assumed a specific format.)
</li>

<li>
The generational mode for the garbage collector was removed.
(It was an experimental feature in Lua&nbsp;5.2.)
</li>

</ul>




<h2>8.2 &ndash; <a name="8.2">Changes in the Libraries</a></h2>
<ul>

<li>
The <code>bit32</code> library has been deprecated.
It is easy to require a compatible external library or,
better yet, to replace its functions with appropriate bitwise operations.
(Keep in mind that <code>bit32</code> operates on 32-bit integers,
while the bitwise operators in standard Lua operate on 64-bit integers.)
</li>

<li>
The Table library now respects metamethods
for setting and getting elements.
</li>

<li>
The <a href="#pdf-ipairs"><code>ipairs</code></a> iterator now respects metamethods and
its <code>__ipairs</code> metamethod has been deprecated.
</li>

<li>
Option names in <a href="#pdf-io.read"><code>io.read</code></a> do not have a starting '<code>*</code>' anymore.
For compatibility, Lua will continue to ignore this character.
</li>

<li>
The following functions were deprecated in the mathematical library:
<code>atan2</code>, <code>cosh</code>, <code>sinh</code>, <code>tanh</code>, <code>pow</code>,
<code>frexp</code>, and <code>ldexp</code>.
You can replace <code>math.pow(x,y)</code> with <code>x^y</code>;
you can replace <code>math.atan2</code> with <code>math.atan</code>,
which now accepts one or two parameters;
you can replace <code>math.ldexp(x,exp)</code> with <code>x * 2.0^exp</code>.
For the other operations,
you can either use an external library or
implement them in Lua.
</li>

<li>
The searcher for C loaders used by <a href="#pdf-require"><code>require</code></a>
changed the way it handles versioned names.
Now, the version should come after the module name
(as is usual in most other tools).
For compatibility, that searcher still tries the old format
if it cannot find an open function according to the new style.
(Lua&nbsp;5.2 already worked that way,
but it did not document the change.)
</li>

</ul>




<h2>8.3 &ndash; <a name="8.3">Changes in the API</a></h2>


<ul>

<li>
Continuation functions now receive as parameters what they needed
to get through <code>lua_getctx</code>,
so <code>lua_getctx</code> has been removed.
Adapt your code accordingly.
</li>

<li>
Function <a href="#lua_dump"><code>lua_dump</code></a> has an extra parameter, <code>strip</code>.
Use 0 as the value of this parameter to get the old behavior.
</li>

<li>
Functions to inject/project unsigned integers
(<code>lua_pushunsigned</code>, <code>lua_tounsigned</code>, <code>lua_tounsignedx</code>,
<code>luaL_checkunsigned</code>, <code>luaL_optunsigned</code>)
were deprecated.
Use their signed equivalents with a type cast.
</li>

<li>
Macros to project non-default integer types
(<code>luaL_checkint</code>, <code>luaL_optint</code>, <code>luaL_checklong</code>, <code>luaL_optlong</code>)
were deprecated.
Use their equivalent over <a href="#lua_Integer"><code>lua_Integer</code></a> with a type cast
(or, when possible, use <a href="#lua_Integer"><code>lua_Integer</code></a> in your code).
</li>

</ul>




<h1>9 &ndash; <a name="9">The Complete Syntax of Lua</a></h1>

<p>
Here is the complete syntax of Lua in extended BNF.
As usual in extended BNF,
{A} means 0 or more As,
and [A] means an optional A.
(For operator precedences, see <a href="#3.4.8">&sect;3.4.8</a>;
for a description of the terminals
Name, Numeral,
and LiteralString, see <a href="#3.1">&sect;3.1</a>.)




<pre>

	chunk ::= block

	block ::= {stat} [retstat]

	stat ::=  &lsquo;<b>;</b>&rsquo; | 
		 varlist &lsquo;<b>=</b>&rsquo; explist | 
		 functioncall | 
		 label | 
		 <b>break</b> | 
		 <b>goto</b> Name | 
		 <b>do</b> block <b>end</b> | 
		 <b>while</b> exp <b>do</b> block <b>end</b> | 
		 <b>repeat</b> block <b>until</b> exp | 
		 <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b> | 
		 <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b> | 
		 <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b> | 
		 <b>function</b> funcname funcbody | 
		 <b>local</b> <b>function</b> Name funcbody | 
		 <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist] 

	retstat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]

	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;

	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]

	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}

	var ::=  Name | prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; | prefixexp &lsquo;<b>.</b>&rsquo; Name 

	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}

	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}

	exp ::=  <b>nil</b> | <b>false</b> | <b>true</b> | Numeral | LiteralString | &lsquo;<b>...</b>&rsquo; | functiondef | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;

	functioncall ::=  prefixexp args | prefixexp &lsquo;<b>:</b>&rsquo; Name args 

	args ::=  &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo; | tableconstructor | LiteralString 

	functiondef ::= <b>function</b> funcbody

	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>

	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;

	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp

	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;

	binop ::=  &lsquo;<b>+</b>&rsquo; | &lsquo;<b>-</b>&rsquo; | &lsquo;<b>*</b>&rsquo; | &lsquo;<b>/</b>&rsquo; | &lsquo;<b>//</b>&rsquo; | &lsquo;<b>^</b>&rsquo; | &lsquo;<b>%</b>&rsquo; | 
		 &lsquo;<b>&amp;</b>&rsquo; | &lsquo;<b>~</b>&rsquo; | &lsquo;<b>|</b>&rsquo; | &lsquo;<b>&gt;&gt;</b>&rsquo; | &lsquo;<b>&lt;&lt;</b>&rsquo; | &lsquo;<b>..</b>&rsquo; | 
		 &lsquo;<b>&lt;</b>&rsquo; | &lsquo;<b>&lt;=</b>&rsquo; | &lsquo;<b>&gt;</b>&rsquo; | &lsquo;<b>&gt;=</b>&rsquo; | &lsquo;<b>==</b>&rsquo; | &lsquo;<b>~=</b>&rsquo; | 
		 <b>and</b> | <b>or</b>

	unop ::= &lsquo;<b>-</b>&rsquo; | <b>not</b> | &lsquo;<b>#</b>&rsquo; | &lsquo;<b>~</b>&rsquo;

</pre>

<p>








<HR>
<SMALL CLASS="footer">
Last update:
Tue Jan  6 10:10:50 BRST 2015
</SMALL>
<!--
Last change: revised for Lua 5.3.0 (final)
-->

</body></html>

